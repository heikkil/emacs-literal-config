#+TITLE: Literal Emacs Configuration
#+AUTHOR: Heikki Lehväslaiho
#+EMAIL: heikki.lehvaslaiho@gmail.com


* Emacs Configuration

  This is  [[https://github.com/heikkil/emacs-literal-config][my version]] of Joost Diepenmaat's Org-Babel and a literate
  programming style emacs configuration. I forked his original
  [[https://github.com/joodie/emacs-literal-config/][Github repository]] on 1st November 2013.

* How to use this configuration

** Obtaining the source

   You can find the latest public version of the configuration in [[https://github.com/heikkil/emacs-literal-config/][my
   Github repository]]. The meat of it (and the source of this
   document) is the ~emacs.org~ file.

** Installation

   This configuration is installable from scratch. It uses [[https://github.com/cask/cask][Cask]] to
   specify the package dependencies. [[https://github.com/rdallasgray/pallet][Pallet]] syncs the actual installed
   packages with the dependency spec.

** Installation procedure

  - Install GNU Emacs 24 or higher
  - Install Cask from https://github.com/cask/cask
  - Clone [[https://github.com/heikkil/emacs-literal-config][the repository]] as ~$HOME/.emacs.d~ (or symlink it to that
    directory).
  - Run ~cask install~ in ~$HOME/.emacs.d~
  - Make sure ~$HOME/.emacs.el~ does not exist
  - Start Emacs

** Issues installing

  - Emacs failing to load pallet can indicate that ~cask~ is
    attempting to install packages using a different Emacs version
    than the one you're starting. Check your ~$PATH~ and/or aliases.

  - Emacs should load this configuration without errors in a vanilla
    environment. Let me know it this is not the case.

** Upgrading and installing emacs packages

   You should be periodically upgrading you emacs packages. Some
   packages get almost daily fixes. It should be enough to update them
   once a month with =M-x pallet-update=. Do restart emacs after
   the update.

   Every time you make major changes to this document (see [Editing
   this Document]) or upgrade your packages, you are strongly advised to
   note it down to a changelog file (see [ChangeLog mode]).

   New packages are usually installed using command =package-install=
   that is given the package name as an argument. This automatically
   adds them to the [[file:Cask][Cask]] file for tracking.

   A new version of this file is detected by emacs at start up. The
   file =~/.emacs.d/init.el= contains the code for using cask and
   converting this org file to the corresponding emacs listp file,
   =~/emacs.d/emacs.el=. Conversion takes some time, but it is only
   done when the file has changed.

*** Paradox

   Emacs module *[[https://github.com/Bruce-Connor/paradox][paradox]]* adds package ratings to the listing, new
   shortcuts, and customization to package listings. Invoke by =C-x l
   p= ("Emacs, launch paradox") to run =paradox-list-packages=. Press
   =h= to see all keys. Tip: =v= opens the package's home page.

   This is also a convenient place to update packages with =U x=.
   Paradox is now able to use the =async= package to run updates
   without locking the whole emacs.

   You can give feedback if you set up the =paradox-github-token=
   variable to your github token. See the variable's info (=C-h v=)
   for instructions.

   Paradox now does asynchronous background updates. You do not even
   have to call up the paradox window to upgrade packages with
   =paradox-upgrade-packages=.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (use-package paradox
       :config
       (setq paradox-github-token t)
       (setq paradox-execute-asynchronously t)
       (setq paradox-automatically-star t))
   #+END_SRC

*** Upgrading Org

    The core org-mode package can not be upgraded when it is in use.
    Do it monthly by starting bare emacs at the command line:

   #+BEGIN_SRC sh
     /usr/local/bin/emacs -Q
     M-x package-list-packages
     U x # upgrade & execute
     yes # do upgrade org
     yes # to delete old org
     C-x C-c  # quit emacs
     # restart graphical emacs
   #+END_SRC

**** TODO Automatic org upgades

     Last time I upgraded emacs packages the org package was there in
     the list and got upgraded without any problems. I have not seen
     anything announcing this so let's see how things develop.

** Editing this document

   Use emacs and version >8 of org-mode for editing. To do that
   effectively, you need to understand how this documents works.

   When emacs starts, code in =$HOME/init.el= loads first the
   prerequisites and then this org document. The code in the
   configuration section (see Chapter [[Configuration file layout]]) scans
   the code blocks and extracts (tangles in literate programming talk)
   them into the =emacs.el= file and evaluates it. The name and the
   order of blocks in this document determine the final order
   statements. Blocks without names are *not* tangled.

   The text and its headers can be in any order that best helps
   understanding the structure. These elements are not read by emacs
   at all. The emacs lisp code that configures emacs is in emacs-lisp
   code blocks.

   The best way to edit existing code blocks is to open a separate
   buffer for it by placing the cursor in it and pressing =C-c '​=.
   After editing, activate the code =M-x eval-buffer= and exit
   the buffer with =C-c '​=.

   If you want to get a better understanding what any lisp code below
   do, view it in a lisp buffer, place the cursor at the word, and
   press =C-h f= on a function or =C-h v= on a variable.

* Graphics and looks

** Font

   The new OS X standard front, Menlo, is amazingly good to eye. It is
   almost [[http://9-bits.com/post/123940811/menlo-font-macosx][the same]] as DejaVu Sans Mono. I have suspended the use of
   [[http://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] ([[http://www.levien.com/type/myfonts/Inconsolata.otf][Download]]) while keeping [[http://zhm.github.io/symbola/][Symbola]] ([[http://zhm.github.io/symbola/fonts/Symbola.otf][Download]]) as a
   Unicode backup (see [[http://endlessparentheses.com/manually-choose-a-fallback-font-for-unicode.html][EndlessParentheses]]).

  #+name: look-and-feel
   #+BEGIN_SRC emacs-lisp
     ;;(set-face-attribute 'default nil
     ;;                    :family "Inconsolata"
     ;;                    :height 140
     ;;                    :weight 'normal
     ;;                    :width 'normal)
     (set-fontset-font "fontset-default" nil
                       (font-spec :size 20 :name "Symbola:"))
   #+END_SRC

   You can use =C-x C-+= and =C-x C--= (‘text-scale-adjust’) to
   increase or decrease the buffer text size in the current buffer
   (=C-+= or =C--= to repeat). To restore the default (global) face
   height, type =C-x C-0=. (From [[http://www.emacswiki.org/emacs/SetFonts][EmacsWiki]])

   The best way to get information about cursor location is to run
   =what-cursor-position= with prefix argument: *C-u C-x =*. It will
   open a *Help* window and show information about character,
   encoding, fonts and highlights. Also, see =M-x what-face=.

*** TODO Unicode
    - Xah Lee's [[http://ergoemacs.org/emacs/emacs_n_unicode.html][Unicode]] page for easy copy and paste.
    - Draw Unicode characters [[http://shapecatcher.com/][online]].
    - Enter Unicode characters in hexadecimal or named: =C-x 8<Enter>=.

   #+name: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (defun my/insert-unicode (unicode-name)
       "Same as C-x 8 enter UNICODE-NAME."
       (insert-char (cdr (assoc-string unicode-name (ucs-names)))))

     (bind-key "C-x 9" 'hydra-unicode/body)
     (defhydra hydra-unicode (:hint nil)
         "
      Unicode  _e_ €  _s_ 0W SPACE
                      _f_ ♀  _o_ °   _m_ µ
                      _r_ ♂  _a_ →
             "
         ("e" (my/insert-unicode "EURO SIGN"))
         ("r" (my/insert-unicode "MALE SIGN"))
         ("f" (my/insert-unicode "FEMALE SIGN"))
         ("s" (my/insert-unicode "ZERO WIDTH SPACE"))
         ("o" (my/insert-unicode "DEGREE SIGN"))
         ("a" (my/insert-unicode "RIGHTWARDS ARROW"))
       ("m" (my/insert-unicode "MICRO SIGN")))
   #+END_SRC

** Reduce clutter

   Remove the toolbar. It's ugly and I never use it. I keep the
   scroll bars on right -- horizontal space is cheep. Below, I set up
   the fringe to the left.

   #+name: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (when (window-system)
       (tool-bar-mode -1)
       (scroll-bar-mode (quote right)))
   #+END_SRC

** Symbols

   Show written out symbols as they should be. This is available only
   in emacs 24.4 and above. The replacements are in variable
   =prettify-symbols-alist=. Currently it only displays “lambda” as
   "λ" in lisp code.

   #+name: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode 1)
   #+END_SRC

** Fringe decorations

   [[http://www.emacswiki.org/emacs/TheFringe][The fringe]] is the vertical region at the right and left of the
   buffer. Emacs lets you customize it of course.

   Here I set up *git differences* and buffer boundaries in the left
   fringe.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (when (window-system)
       (use-package git-gutter-fringe
         :config
         (global-git-gutter-mode +1)
         (setq-default indicate-buffer-boundaries 'left)
         (setq-default indicate-empty-lines +1)
         :diminish git-gutter-mode))
   #+END_SRC

** Mode line

   The default emacs mode line is confusing and boring. [[ http://amitp.blogspot.com/2011/08/emacs-custom-mode-line.html][This setup]]
   makes it clear and easy to eye. Some might argue that the amount of
   code used is excessive for such a small feature, but since I was
   able to copy, paste and modify, why not.

   Futher, package *diminish* makes it easy to remove or change any
   minor mode indicators on the mode line. The code using diminish is
   placed where the corresponding minor mode is set up.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (setq-default
      mode-line-format
      '(;; Position, including warning for 80 columns
        (:propertize " %5l:" face mode-line-position-face)
        (:eval (propertize "%3c" 'face
                           (if (>= (current-column) 80)
                               'mode-line-80col-face
                             'mode-line-position-face)))
        ;; emacsclient [default -- keep?]
        mode-line-client
        " "
        ;; read-only or modified status
        (:eval
         (cond (buffer-read-only
                (propertize " RO " 'face 'mode-line-read-only-face))
               ((buffer-modified-p)
                (propertize " ** " 'face 'mode-line-modified-face))
               (t "    ")))
        " "
        ;; directory and buffer/file name
        (:propertize (:eval (shorten-directory default-directory 30))
                     face mode-line-folder-face)
        (:propertize "%b"
                     face mode-line-filename-face)
        ;; narrow [default -- keep?]
        " %n "

        ;; mode indicators:
        ;; vc, recursive edit, major mode, minor modes, process, global
        (vc-mode vc-mode)
        "  %["
        (:propertize mode-name
                     face mode-line-mode-face)
        "%] "
        (:eval (propertize (format-mode-line minor-mode-alist)
                           'face 'mode-line-minor-mode-face))
        " "
        (:propertize mode-line-process
                     face mode-line-process-face)
        (global-mode-string global-mode-string)

        ))

     ;; Helper function
     (defun shorten-directory (dir max-length)
       "Show up to `max-length' characters of a directory name `dir'."
       (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
             (output ""))
         (when (and path (equal "" (car path)))
           (setq path (cdr path)))
         (while (and path (< (length output) (- max-length 4)))
           (setq output (concat (car path) "/" output))
           (setq path (cdr path)))
         (when path
           (setq output (concat ".../" output)))
         output))

     ;; Extra mode line faces
     (make-face 'mode-line-read-only-face)
     (make-face 'mode-line-modified-face)
     (make-face 'mode-line-folder-face)
     (make-face 'mode-line-filename-face)
     (make-face 'mode-line-position-face)
     (make-face 'mode-line-mode-face)
     (make-face 'mode-line-minor-mode-face)
     (make-face 'mode-line-process-face)
     (make-face 'mode-line-80col-face)


     (set-face-attribute 'mode-line nil
                         :foreground "gray60" :background "gray20"
                         :inverse-video nil
                         :box '(:line-width 6 :color "gray20" :style nil))
     (set-face-attribute 'mode-line-inactive nil
                         :foreground "gray80" :background "gray40"
                         :inverse-video nil
                         :box '(:line-width 6 :color "gray40" :style nil))
     (set-face-attribute 'mode-line-read-only-face nil
                         :inherit 'mode-line-face
                         :foreground "grey80"
                         :box '(:line-width 2 :color "#4271ae"))
     (set-face-attribute 'mode-line-modified-face nil
                         :inherit 'mode-line-face
                         :foreground "#c82829"
                         :background "#ffffff"
                         :box '(:line-width 2 :color "#c82829"))
     (set-face-attribute 'mode-line-folder-face nil
                         :inherit 'mode-line-face
                         :foreground "gray60")
     (set-face-attribute 'mode-line-filename-face nil
                         :inherit 'mode-line-face
                         :foreground "#eab700"
                         :weight 'bold)
     (set-face-attribute 'mode-line-position-face nil
                         :inherit 'mode-line-face
                         :height 130)
     (set-face-attribute 'mode-line-mode-face nil
                         :inherit 'mode-line-face
                         :foreground "gray80")
     (set-face-attribute 'mode-line-minor-mode-face nil
                         :inherit 'mode-line-mode-face
                         :foreground "gray60"
                         :height 100)
     (set-face-attribute 'mode-line-process-face nil
                         :inherit 'mode-line-face
                         :foreground "grey80")
     (set-face-attribute 'mode-line-80col-face nil
                         :inherit 'mode-line-position-face
                         :foreground "black" :background "#eab700")
   #+END_SRC

** Visual bell

   Getting boings from emacs when you scroll to the end of the buffer
   is annoying. Turning that noise into visual clue is much better. The
   following code blinks the message area before displaying the error
   message.

   The =mode-line-bell-string= is not displayed which is disappointing.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     ;; nice little alternative visual bell; Miles Bader <miles /at/ gnu.org>
     (defcustom echo-area-bell-string "♪ ♪ ♪"
       "Message displayed in echo area by `echo-area-bell' function."
       :group 'user)

     (defcustom echo-area-bell-delay 0.1
       "Number of seconds `echo-area-bell' displays its message."
       :group 'user)

     ;; internal variables
     (defvar echo-area-bell-cached-string nil)
     (defvar echo-area-bell-propertized-string nil)

     (defun echo-area-bell ()
       "Briefly display a highlighted message in the echo-area.
         The string displayed is the value of `echo-area-bell-string',
         with a red background; the background highlighting extends to the
         right margin.  The string is displayed for `echo-area-bell-delay'
         seconds.
         This function is intended to be used as a value of `ring-bell-function'."
       (unless (equal echo-area-bell-string echo-area-bell-cached-string)
         (setq echo-area-bell-propertized-string
               (propertize
                (concat
                 (propertize
                  "*DING* "
                  'display
                  `(space :align-to (- right ,(+ 2 (length echo-area-bell-string)))))
                 echo-area-bell-string)
                'face '(:background "red")))
         (setq echo-area-bell-cached-string echo-area-bell-string))
       (message echo-area-bell-propertized-string)
       (sit-for echo-area-bell-delay)
       (message ""))

     (setq ring-bell-function 'echo-area-bell)
#+END_SRC


** Scrolling behavior

   Emacs's default scrolling behavior, like a lot of the default
   Emacs experience, is pretty idiosyncratic. The following snippet
   makes for a smoother scrolling behavior when using keyboard
   navigation.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (setq redisplay-dont-pause t
           scroll-margin 1
           scroll-step 1
           scroll-conservatively 10000
           scroll-preserve-screen-position 1)
   #+END_SRC

   This snippet makes mouse wheel and trackpad scrolling
   bearable. Scroll in 1-line increments the buffer under the mouse.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (setq mouse-wheel-follow-mouse 't)
     (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
   #+END_SRC

   The other aspect of scrolling is centering. =C-l= is bound to
   command recenter-top-bottom that places the current line vertically
   in the center of the page. A less known feature of it is that you
   cycle the placement between middle, top, and bottom. This can be
   [[http://oremacs.com/2015/03/28/recenter/][reordered]] and I've followed the suggestion to place the current
   line first to the top of the frame.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (setq recenter-positions '(top middle bottom))
   #+END_SRC

*** Scroll other window

    Often you are working in one window and reading instructions from
    an other window. This defines key bindings to scroll this and the
    other window using =M-s-<arrow>=.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     (bind-key "M-s-<down>" 'scroll-down)
     (bind-key "M-s-<up>" 'scroll-up)
     (bind-key "M-s-<right>" 'scroll-other-window)
     (bind-key "M-s-<left>" #'(lambda () (interactive) (scroll-other-window '-)))
   #+END_SRC

    The default keybindings are complex or do not work under OS X and
    a laptop keyboard.

** Cursor

   The cursor shows the location between characters except in [[Evil
   mode]] when it becomes a transparent box.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
      (modify-all-frames-parameters (list (cons 'cursor-type 'bar)))
      (setq blink-cursor-mode nil)
      ;; show tab length
      (setq-default x-stretch-cursor t)
   #+END_SRC

   [[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html][Stop cursor going into minibuffer prompt]]

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
     ;; don't let the cursor go into minibuffer prompt
     (setq minibuffer-prompt-properties
           (quote (read-only t point-entered minibuffer-avoid-prompt
                             face minibuffer-prompt)))
   #+END_SRC


** Current line

   Current line is subtly highlighted in pale blue.

   #+NAME: look-and-feel
   #+BEGIN_SRC emacs-lisp
    (when (window-system)
     (global-hl-line-mode 1)
     (set-face-background hl-line-face "AliceBlue"))
   #+END_SRC

** Global key bindings

   As far as reasonable, I try to keep my custom key bindings within
   the "official" restraints. Specifically, I want my global key
   bindings to start with =C-c [lower case letter]=. Implementations are
   in appropriate sections below.

* Start-up

  Start with the scratch buffer; no start-up screen. Restore previous
  window and file setup including window placement.

  #+NAME: startup
  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-screen +1)
    ; emacs 24.4 feature, call on main windowed emacs
    (when (window-system)
      (desktop-save-mode 1))
  #+END_SRC

** Identify yourself

   Many emacs modes produce output that includes user's name and email
   address. Set your full name (using plain ASCII to guard against
   conflicts with old modes).

   You can tell emacs your preferred email address by hard coding it.
   An alternative is to add it to your global shell environment (you
   are using *NIX operating system, aren't you?) where emacs will pick
   it up (from =~/.zshenv= or =~/.bash_profile=):

   #+BEGIN_SRC sh
     export EMAIL=heikki.lehvaslaiho@gmail.com"
   #+END_SRC

   #+NAME: startup
   #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Heikki Lehväslaiho")
    (setq user-mail-address "heikki.lehvaslaiho@gmail.com")
   #+END_SRC

* Backups

  Default emacs behaviour is to clutter document directories with its
  backup files. The following creates numbered backups, limits the
  number of backups kept, and directs them all into
  =$HOME/.emacs.d/backups/= directory.

  Lockfiles with names prefixed with ".#" are an other type of Emacs
  clutter. I am not afraid of double editing, so I disable that.


  #+NAME: startup
  #+BEGIN_SRC emacs-lisp
    (setq make-backup-files t) ;; Enable backup files
    ;; Enable versioning
    (setq version-control t)  ;; make numbered backups
    (setq backup-by-copying t)
    (setq kept-new-versions 6)
    (setq kept-old-versions 10)
    (setq delete-old-versions t)
    ;; Save all backup files in this directory.
    (setq backup-directory-alist (quote ((".*" . "~/.emacs.d/backups/"))))

    ;; disable lockfiles
    (setq create-lockfiles nil)
  #+END_SRC

* Confirmations and quitting emacs

  Set short y/n abbreviations for all confirmations and ask for
  confirmation before quiting emacs.

  #+NAME: startup
  #+BEGIN_SRC emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
    (setq confirm-kill-emacs 'y-or-n-p)
  #+END_SRC

  Emacs pops up an annoying buffer when big chunks of text get
  replaced overflowing the undo buffer. Prevent that.

  Emacs can crash if it tries to open a too large file. If it detects
  a one, it will ask: "file foo is large (12MB); really open?". My
  elfeed index is regularly over the default 10MB, so lets increase
  the limit to 100 MB. Modern computers can easily handle that.

  #+NAME: startup
  #+BEGIN_SRC emacs-lisp
    (setq warning-suppress-types (quote ((undo discard-info))))
    (setq large-file-warning-threshold 100000000)
  #+END_SRC

* Key bindings

  The Endless Parentheses blog shows how to set up [[http://endlessparentheses.com/the-toggle-map-and-wizardry.html][mnemonic keymaps]].
  You just do the incantation "Emacs, toggle narrowing" by pressing
  =C-x t n=!

  This is now done even better with [[https://github.com/abo-abo/hydra][hydra]], a package to
  create sticky key bindings with help displayed in the echo area.

  Using =bind-key= function adds the key bindings to a list that can
  be shown with =M-x describe-personal-keybindings=.

  #+name: key-bindings
  #+BEGIN_SRC emacs-lisp
    (bind-key "C-x t" 'hydra-toggle/body)
    (defhydra hydra-toggle (:color blue :hint nil)
      "
         toggle _a_bbrev-mode             _p_retty entities
                _d_ebug-on-error          t_r_uncate-lines
                _f_olding                 white_s_pace-mode
                _i_edit                   neo_t_ree
                _n_arrowing               _v_: string inflection
                _l_inum-mode              _w_ritegood-mode
                _k_: spelling language    _q_uit
              "
      ("a" abbrev-mode )
      ("d" toggle-debug-on-error)
      ("f" toggle-selective-display)
      ("i" iedit-mode)
      ("n" narrow-or-widen-dwim)
      ("l" my/global-linum-mode)
      ("k" cycle-ispell-languages :color red)
      ("p" org-toggle-pretty-entities)
      ("r" toggle-truncate-lines)
      ("s" whitespace-mode)
      ("t" neotree-toggle)
      ("v" string-inflection-toggle :color red)
      ("w" writegood-mode)
      ("q" nil))

    (bind-key "C-x C-0" 'hydra-zoom/body)
    (defhydra hydra-zoom ()
      "zoom"
      ("g" text-scale-increase "in")
      ("=" text-scale-increase "in")
      ("l" text-scale-decrease "out")
      ("-" text-scale-decrease "out"))

    ;; http://oremacs.com/2015/03/07/hydra-org-templates/
    ;; https://github.com/abo-abo/hydra/wiki/Org-mode-block-templates
    (defhydra hydra-org-template (:color blue :hint nil)
      "
       org-template  _c_enter  _q_uote     _e_macs-lisp    _L_aTeX:
                     _l_atex   _E_xample   _p_erl          _i_ndex:
                     _a_scii   _v_erse     _P_erl tangled  _I_NCLUDE:
                     _s_rc     ^ ^         plant_u_ml      _H_TML:
                     _h_tml    ^ ^         ^ ^             _A_SCII:
           "
      ("s" (hot-expand "<s"))
      ("E" (hot-expand "<e"))
      ("q" (hot-expand "<q"))
      ("v" (hot-expand "<v"))
      ("c" (hot-expand "<c"))
      ("l" (hot-expand "<l"))
      ("h" (hot-expand "<h"))
      ("a" (hot-expand "<a"))
      ("L" (hot-expand "<L"))
      ("i" (hot-expand "<i"))
      ("e" (progn
             (hot-expand "<s")
             (insert "emacs-lisp")
             (forward-line)))
      ("p" (progn
             (hot-expand "<s")
             (insert "perl")
             (forward-line)))
      ("u" (progn
             (hot-expand "<s")
             (insert "plantuml :file CHANGE.png")
             (forward-line)))
      ("P" (progn
             (insert "#+HEADERS: :results output :exports both :shebang \"#!/usr/bin/env perl\"\n")
             (hot-expand "<s")
             (insert "perl")
             (forward-line)))
      ("I" (hot-expand "<I"))
      ("H" (hot-expand "<H"))
      ("A" (hot-expand "<A"))
      ("<" self-insert-command "ins")
      ("o" nil "quit"))

    (defun hot-expand (str)
      "Expand org template."
      (insert str)
      (org-try-structure-completion))

    ;; I bind it for myself like this:

    (define-key org-mode-map "<"
      (lambda () (interactive)
        (if (looking-back "^")
            (hydra-org-template/body)
          (self-insert-command 1))))

    ;; http://oremacs.com/2015/03/15/search-with-apropos/
    (bind-key "C-c h" 'hydra-apropos/body)
    (defhydra hydra-apropos (:color blue :hint nil)
      "
      apropos   _a_propos        _c_ommand
                _d_ocumentation  _l_ibrary
                _v_ariable       _u_ser-option
                ^ ^              _e_: value"
      ("a" apropos)
      ("d" apropos-documentation)
      ("v" apropos-variable)
      ("c" apropos-command)
      ("l" apropos-library)
      ("u" apropos-user-option)
      ("e" apropos-value))
  #+END_SRC

  The second key map is for *launching* [[http://endlessparentheses.com/launcher-keymap-for-standalone-features.html][standalone features]].
  This is like casting a spell "Emacs, launch shell", =C-x l s=.
  The hydra implementing this is self-documenting.

  #+name: key-bindings
  #+BEGIN_SRC emacs-lisp
    (bind-key "C-x l" 'hydra-launch/body)
    (defhydra hydra-launch (:color blue :hint nil)
      "
    launch _2_048           _l_ink chrome   _p_aradox
           _c_: quick-calc  _n_ato-region   _q_: paradox upgrade
           _e_diff-buffers  de_N_ato        _t_imemachine git
           _g_scholar-bib   _r_e-builder    _w_3m at point
           _h_owdoi         e_s_hell        _?_: emacsExchange
           tw_i_tter        ^ ^             G_\+_ emacs
          "
      ("2" 2048-game)
      ("c" quick-calc)
      ("e" ediff-buffers)
      ("g" gscholar-bibtex)
      ("h" howdoi-query)
      ("i" twit)
      ("l" org-mac-chrome-insert-frontmost-url)
      ("n" nato-region)
      ("N" denato-region)
      ("r" re-builder)
      ("s" eshell)
      ("p" paradox-list-packages)
      ("q" paradox-upgrade-packages)
      ("t" git-timemachine)
      ("w" browse-url-at-point)
      ("?" (browse-url "http://emacs.stackexchange.com/"))
      ("+" (browse-url "https://plus.google.com/communities/114815898697665598016")))
  #+END_SRC

  The following tables lists all other additions or modifications to
  standard key bindings.

  | prefix |                                           |                              |
  | C-c    | function                                  | link                         |
  |--------+-------------------------------------------+------------------------------|
  | esc    | evil-normal-state                         | [[Evil mode]]                    |
  | 2      | 2048-game                                 | [[2048-game]]                    |
  | =      |                                           |                                  |
  | a      | org-agenda                                | [[Org Mode]]                     |
  | b      | my/quick-url-note                         | [[URL copying]]                  |
  | c      | org-capture                               | [[Org Mode]]                     |
  | d      | delete-file-and-buffer                    | [[Abbreviations]]                |
  | e      | my/edit-emacs-configuration               | [[Global navigation]]            |
  | f      | elfeed                                    | [[News feed reader]]             |
  | g      | magit-status                              | [[Magit]]                        |
  | h      | hydra-apropos/body                        |                              |
  | i      | my/org-babel-untangle                     | [[Org-Babel]]                    |
  | j      |                                           |                              |
  | k      | my/aspell-word-then-abbrev                | [[Spell checking]]               |
  | l      | org-store-link                            | [[Org Mode]]                     |
  | m      | macrostep-expand                          | [[Lisps]]                        |
  | n      | my/clean-buffer-formatting                | [[Formatting and white-space]]   |
  | o      | org-page                                  | [[Blogging with org-page]]       |
  | p      | projectile                                | [[Projects]]                     |
  | q      | delete-indentation                        | [[Local navigation in a buffer]] |
  | r      | recentf-ido-find-file                     | [[Global navigation]]            |
  | s      |                                           |                              |
  | (t)    | languagetool-mode (disabled)              | [[Writing style]]                |
  | u      | set-buffer-file-coding-system 'utf-8-unix | [[Character encoding]]           |
  | w      | wcheck-mode                               | [[Spell checking]]               |
  | x      | xkcd                                      | [[xkcd comics]]                  |
  | y      | scroll-other-window down                  | [[Scroll other window]]          |
  | Y      | scroll-other-window up                    | [[Scroll other window]]          |
  | z      | hydra-goto/body                           |                              |
  |        |                                           |                              |
  | C-g g  | writegood-grade-level                     | [[Writing style]]                |
  | C-g e  | writegood-reading-ease                    | [[Writing style]]                |
  |        |                                           |                              |


  | prefix |                    |                              |
  | C-x    | function           | link                         |
  |--------+--------------------+------------------------------|
  | ,      | goto-line          | [[Local navigation in a buffer]] |
  | C-r    | recentf-open-files | [[Global navigation]]            |


  | All other   | function                       | link                         |
  |-------------+--------------------------------+------------------------------|
  | M-Q         | unfill-paragraph               | [[Text (non-code) formatting]]   |
  | M-;         | comment-dwim-2                 | [[Commenting]]                   |
  | C-backspace | kill-line 0                    | [[Local navigation in a buffer]] |
  | M-j         | (join-line -1)                 | [[Local navigation in a buffer]] |
  | C-=         | er/expand-region               | [[Expand region]]                |
  | C-a         | smarter-move-beginning-of-line | [[Local navigation in a buffer]] |
  | s-p         | mac-print-buffer               | [[Printing]]                     |


  And finally, to here is definition to =keys-describe-prefixes=
  function from [[http://oremacs.com/2015/02/11/elisp-newbie-style/][Elisp newbie-style]] blog to print out all key bindings
  in the current buffer. I do not use greek letters in keys, so I've removed them

  #+name: key-bindings
  #+BEGIN_SRC emacs-lisp
    ;;;###autoload
    (defun keys-describe-prefixes ()
      (interactive)
      (with-output-to-temp-buffer "*Bindings*"
        (dolist (letter-group (list
                               (cl-loop for c from ?a to ?z
                                        collect (string c))
                               (cl-loop for c from ?A to ?Z
                                        collect (string c))))
          (dolist (prefix '("" "C-" "M-" "C-M-"))
            (princ (mapconcat
                    (lambda (letter)
                      (let ((key (concat prefix letter)))
                        (format ";; (global-set-key (kbd \"%s\") '%S)"
                                key
                                (key-binding (kbd key)))))
                    letter-group
                    "\n"))
            (princ "\n\n")))))
  #+END_SRC
* Evil mode

  I am trying out [[http://gitorious.org/evil/pages/Home][evil mode]] that adds vi-like modal editing and cursor
  moving to emacs.

  Evil mode uses [[https://elpa.gnu.org/packages/undo-tree-readme.txt][undo-tree]] but I disable it to keep emacs' own powerful
  albeit sometimes confusing cyclic undo system.

  Vi and evil works in states of which most important are the *normal*
  for navigating and editing, and *insert* for typing. I am replacing
  the insert state with emacs state that is not tainted by evil mode at
  all. Pressing =<ESC>= quits from any evil function and also to returns
  from the emacs editing mode to evil normal mode (as does =,,=).

  I have added visual clues to the mode line for different states: The
  *black* background color of the mode line changes to blue if the
  buffer is in insert mode. Likewise, the *hollow block cursor* on
  normal mode changes to *bar* in insert mode. The red double asterisk
  in the mode line for a changed buffer is already defined at [[Mode
  line]].

  [[https://github.com/timcharper/evil-surround][evil-surround]] is a plugin that enhances the evil mode to add, change
  and delete triggers. These triggers can be characters (like quotes
  and brackets) or tags (HTML) around strings.

  | function | syntax                                 |
  |----------+----------------------------------------|
  | add      | y s <textobject> <trigger>             |
  | change   | c s <old-trigger> <new-trigger>.       |
  | delete   | d s <trigger>                          |
  | function | [select argument]: s f <function name> |
  |          |                                        |

  #+name: formatting
  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :init
      (setq evil-default-state 'normal)
      (setq evil-emacs-state-cursor    '("red" bar))
      (setq evil-normal-state-cursor   '("red" hollow))
      (setq evil-visual-state-cursor   '("green" hollow))
      (setq evil-insert-state-cursor   '("blue" bar))
      (setq evil-replace-state-cursor  '("red" bar))
      (setq evil-operator-state-cursor '("red" hollow))
      :config
      ;; I like the cyclic emacs undo
      (global-undo-tree-mode -1)

      ;; Clear the insert state keymap to unadulterated Emacs behavior
      (setcdr evil-insert-state-map nil)
      (define-key evil-insert-state-map
        (read-kbd-macro evil-toggle-key) 'evil-emacs-state)

      (evil-set-initial-state 'magit-log-edit-mode 'emacs)
      (evil-set-initial-state 'elfeed-search 'emacs)

      ;;; ESC quits always
      (defun minibuffer-keyboard-quit ()
        "Abort recursive edit.
      In Delete Selection mode, if the mark is active, just deactivate it;
      then it takes a second \\[keyboard-quit] to abort the minibuffer."
        (interactive)
        (if (and delete-selection-mode transient-mark-mode mark-active)
            (setq deactivate-mark  t)
          (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
          (abort-recursive-edit)))

      (define-key evil-normal-state-map [escape] 'keyboard-quit)
      (define-key evil-visual-state-map [escape] 'keyboard-quit)
      (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
      (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)

      (global-set-key [escape] 'evil-normal-state)

      ;; Don't wait for any other keys after escape is pressed.
      (setq evil-esc-delay 0)

      ;; double comma pressed rapidly returns to normal state, too
      ;;(use-package key-chord
      ;;  (key-chord-mode 1)
      ;;  (key-chord-define-global ",," 'evil-normal-state))

      ;; fix selection anomaly
      (setq evil-want-visual-char-semi-exclusive t)

      ;; Remap org-mode meta keys for convenience
      (mapcar (lambda (state)
                (evil-declare-key state org-mode-map
                  (kbd "M-l") 'org-metaright
                  (kbd "M-h") 'org-metaleft
                  (kbd "M-k") 'org-metaup
                  (kbd "M-j") 'org-metadown
                  (kbd "M-L") 'org-shiftmetaright
                  (kbd "M-H") 'org-shiftmetaleft
                  (kbd "M-K") 'org-shiftmetaup
                  (kbd "M-J") 'org-shiftmetadown))
              '(normal insert))

      ;; change mode-line color for the evil insert state
      ;; original from http://www.emacswiki.org/emacs/Evil#toc16
      ;; also, change cursor to indicate state
      (lexical-let ((default-color (cons (face-background 'mode-line)
                                         (face-foreground 'mode-line))))
        (add-hook 'post-command-hook
                  (lambda ()
                    (let ((color (cond ((minibufferp) default-color)
                                       ((evil-insert-state-p) '("#444488" . "#ffffff"))
                                       ((evil-emacs-state-p)  '("blue" . "#ffffff"))
                                       ((evil-visual-state-p) '("#025a2b" . "#ffffff"))
                                       (t default-color))))
                      (set-face-background 'mode-line (car color))
                      (set-face-foreground 'mode-line (cdr color))))))

      (use-package evil-surround
        :config
        (global-evil-surround-mode 1)))
  #+END_SRC

** TODO evil tutor

   Install [[https://github.com/syl20bnr/evil-tutor][evil-tutor]] to learn. It is adapted from vim's =:h= text.

* Formatting and white-space

** Character encoding

   [[http://ergoemacs.org/emacs/emacs_encoding_decoding_faq.html][Character encoding]] in files and emacs buffers is an important topic
   for anyone dealing with anything other than plain ASCII English. The
   best approach is to assume UTF-8 and deal with anything else
   (Latin-1, UTF-16) only if absolutely have to.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
     (prefer-coding-system 'utf-8) ; same thing as above? in practice?
     (bind-key "C-c u"
               (lambda () (interactive)
                 (set-buffer-file-coding-system 'utf-8-unix t)))
   #+END_SRC

   Tabs are automatically converted to spaces and trailing white space
   is shown. Global key =C-c n= indents and removes trailing white
   space from the buffer.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)

    (defun my/clean-buffer-formatting ()
      "Indent and clean up the buffer"
      (interactive)
      (indent-region (point-min) (point-max))
      (whitespace-cleanup))

    (bind-key "C-c n" 'my/clean-buffer-formatting)

    (defun my/general-formatting-hooks ()
      (setq show-trailing-whitespace 't))

    (dolist (mode-hook (my/normal-mode-hooks))
      (add-hook mode-hook 'my/general-formatting-hooks))
   #+END_SRC

   UNIXy text files should always end in a newline character. This
   tells emacs to take care of it so that you do not have to.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
   (setq require-final-newline t)
   #+END_SRC

   Emacs knows about natural language sentences and can navigate and
   mark them. The default emacs expects sentences that are separated
   by double space like in old typewriter text. Not any more. Note
   that this leads to some ambiguity in detecting sentences.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
   (setq sentence-end-double-space nil)
   #+END_SRC

** Text (non-code) formatting

   For writing text, I prefer Emacs to do line wrapping for me. Also,
   superfluous white-space should needs to be visible.

   [[Abbreviations]] are an important emacs productivity enhancement
   feature. They need to be available in all text buffers.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     (defun my/text-formatting-hooks ()
       (my/turn-on 'auto-fill ; turn on automatic hard line wraps
                   'abbrev))  ;; abbrev-mode on

     (add-hook 'text-mode-hook
               'my/text-formatting-hooks)
   #+END_SRC

   If the line wrapping (explicitely =M-q=) needs to be [[http://www.emacswiki.org/emacs/UnfillParagraph][reversed]], use
   =unfill-paragraph= that is bound to =M-Q=.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     ;; Opposite of fill-paragraph
     (defun unfill-paragraph ()
       "Takes a multi-line paragraph and makes it into a single line of text."
       (interactive)
       (let ((fill-column (point-max)))
         (fill-paragraph nil)))

     ;; Handy key definition
     (bind-key "\M-Q" 'unfill-paragraph)
   #+END_SRC

   Filling, either manual or automatic using =auto-fill-mode= wraps
   lines that are longer than =fill-column=. This is usually modified
   by function =set-fill-column= that is bound to =C-x f=. This key
   combination is close to other common keys that I've frequently
   found myself accidentally modifying the fill-column value from its
   default 70. Hopefully this paragraph helps me to remember how to
   reset it.

** Understand compressed files

   This allows emacs to handle opening and saving .gz files
   automatically.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     (auto-compression-mode)
   #+END_SRC

** Auto refresh buffers

   Automatically update file-associated buffers on file change. Also,
   auto refresh dired files, but be quiet about it.

   #+name: formatting
   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode)
     (setq global-auto-revert-non-file-buffers t)
     (setq auto-revert-verbose nil)
   #+END_SRC

* Editing

** Selecting text

   Usually, you can selected ("mark") text by =S-<arrow>= keys, but in
   my emacs that disabled everywhere.

  The main reason for that is the org mode. Org mode uses =S-<arrow>=
  keys for special functions in lists and headers and disables them in
  other text areas.

  The =S-<arrow>= are now exclusively used for switching windows within
  an emacs frame.

  The preferred way to select text is to press =C-<space>= followed by
  arrow keys to define the region, (but see below).

  I am now using OS X in my main laptop computer and this choice had
  knock-on effects. By default, =C-<space>= pops up the Spotlight
  search field. To circumvent that, I've changed Spotlight key to
  =Cmnd-<space>=. That, in turn, disabled the default key for toggling
  of the active keyboard languages, so the key for that is now
  =Cmnd-alt-<space>=.

*** CUA mode

  The biggest advantage modern emacs has over older ones is CUA-mode.
  It enables common =C-x=, =C-c=, =C-v= keyboard combinations in emacs
  buffers. It also adds an ability to do rectangle (column) editing.
  Press =C-<Return>= to enter it, use arrow keys to select, copy, and
  exit the rectangle editing mode by =C-c=.

  #+name: formatting
  #+BEGIN_SRC emacs-lisp
    (cua-mode t)
  #+END_SRC

*** Expand region

    You can select text incrementally using semantic units with by
    using [[https://github.com/magnars/expand-region.el][expand-region]]: e.g. word, sentence, URL, quotes, paragraph,
    and section. Just press =C-== and expand =\== and contract =-= the
    selection! This works in all text modes including most programming
    languages, and is really convenient!

    [[http://blog.binchen.org/posts/how-to-use-expand-region-efficiently.html][Here]] is an alternative setup for evil.

    #+name: text-files
    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :bind ("C-=" . er/expand-region))
    #+END_SRC

** Cut and copy

   Default cut and copy behaviour in emacs when nothing is selected is
   to do nothing. These functions cut or copy the current line
   instead. I am binding them to =C-x= and =C-c=, and in case of OS X,
   to command key equivalents.

   #+BEGIN_SRC emacs-lisp
     (defun xah-cut-line-or-region ()
       "Cut current line, or text selection.
       When `universal-argument' is called first, cut whole buffer (respects `narrow-to-region').

       URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
       Version 2015-05-06"
       (interactive)
       (let (ξp1 ξp2)
         (if current-prefix-arg
             (progn (setq ξp1 (point-min))
                    (setq ξp2 (point-max)))
           (progn (if (use-region-p)
                      (progn (setq ξp1 (region-beginning))
                             (setq ξp2 (region-end)))
                    (progn (setq ξp1 (line-beginning-position))
                           (setq ξp2 (line-beginning-position 2))))))
         (kill-region ξp1 ξp2)))

     (defun xah-copy-line-or-region ()
       "Copy current line, or text selection.
       When `universal-argument' is called first, copy whole buffer (respects `narrow-to-region').

       URL `http://ergoemacs.org/emacs/emacs_copy_cut_current_line.html'
       Version 2015-05-06"
       (interactive)
       (let (ξp1 ξp2)
         (if current-prefix-arg
             (progn (setq ξp1 (point-min))
                    (setq ξp2 (point-max)))
           (progn (if (use-region-p)
                      (progn (setq ξp1 (region-beginning))
                             (setq ξp2 (region-end)))
                    (progn (setq ξp1 (line-beginning-position))
                           (setq ξp2 (line-end-position))))))
         (kill-ring-save ξp1 ξp2)
         (if current-prefix-arg
             (message "buffer text copied")
           (message "text copied"))))

     (bind-key "C-x" 'xah-cut-line-or-region)
     (bind-key "C-c" 'xah-copy-line-or-region)
     (when (eq system-type 'darwin)
       (bind-key "s-x" 'xah-cut-line-or-region)
       (bind-key "s-c" 'xah-copy-line-or-region))
   #+END_SRC

** Abbreviations

   Emacs comes with =abbrev-mode= that is able to replace typed strings
   in context sensitive way. I use it to correct typos (teh -> the) and
   replace short strings with long, multiline texts in modes that
   I use frequently. I turn this mode on in all modes that are based
   in text-mode.

   #+name: abbreviations
   #+BEGIN_SRC emacs-lisp
     (use-package abbrev
       :disabled nil
       :commands abbrev-mode
       :diminish Abbr
       :init
       (hook-into-modes #'abbrev-mode '(text-mode-hook cperl-mode-hook))

       :config
       (progn
         (if (file-exists-p abbrev-file-name)
             (quietly-read-abbrev-file))
         (setq save-abbrevs t)
         (add-hook 'expand-load-hook
                   (lambda ()
                     (add-hook 'expand-expand-hook 'indent-according-to-mode)
                     (add-hook 'expand-jump-hook 'indent-according-to-mode)))))
   #+END_SRC

   A special form of abbreviation is a time stamp in a file. I do not
   want to see AM/PM time stamps.

   #+name: abbreviations
   #+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook 'time-stamp)
    (setq display-time-24hr-format t)
   #+END_SRC

   To use it, you place a template using bracket or quotes in the first
   8 lines of a file. The time stamp value will be automatically added
   and updated between these delimiters. Typically, the line can start
   with a comment character to mask it from the program processing the
   file.

   #+BEGIN_EXAMPLE
    Time-stamp: <>
    # Time-stamp: " "
   #+END_EXAMPLE

   =insert-buffer-name= does what the name says. This sort of
   metafunction does not really fix in any other category, so I list it
   here among abbreviations. Incidently, renaming a buffer is simply
   =M-x rename-buffer=.

   #+name: abbreviations
   #+BEGIN_SRC emacs-lisp
    (defun insert-buffer-name ()
      "Inserts file name of the buffer on the current buffer."
      (interactive)
      (insert (buffer-name)))
   #+END_SRC

   Similarly, you might want to remove both the current buffer and its
   file (from [[http://emacsredux.com/blog/2013/04/03/delete-file-and-buffer/][Emacs Redux]]). =C-c d= now does it for you in one step and it
   works correctly even when a version control system tracks the file.

   #+name: abbreviations
   #+BEGIN_SRC emacs-lisp
     (defun delete-file-and-buffer ()
       "Kill the current buffer and deletes the file it is visiting."
       (interactive)
       (let ((filename (buffer-file-name)))
         (when filename
           (if (vc-backend filename)
               (vc-delete-file filename)
             (progn
               (delete-file filename)
               (message "Deleted file %s" filename)
               (kill-buffer))))))
     (bind-key "C-c d" 'delete-file-and-buffer)

   #+END_SRC

*** Yasnipppet

    Add your own snippets to ~/.emacs.d/snippets by placing files
    there or invoking yas-new-snippet.

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :config
       (yas-global-mode 1))
   #+END_SRC

** String inflection

   [[http://github.com/akicho8/string-inflection][String inflection]] cycles variable names between camel case and
   underscore-separated states. The mnemonic is "Emacs, toggle
   variable", =C-x t v=.

   #+BEGIN_SRC emacs-lisp
     (use-package string-inflection)
   #+END_SRC

** TODO Spell checking

   [[http://www.emacswiki.org/emacs/FlySpell][Flyspell]] checks words as I write against the [[http://aspell.net/][GNU aspell]]
   dictionaries.

   You might have to install aspell for your computer. For OS X, do it
   using [[http://brew.sh/][Homebrew]] =brew install aspell=. This installs several
   varieties of English. To add more languages, you have to specify
   them as arguments.

   Words added to personal word list are stored in =~/.aspell.{LANG}.pws=,
   e.g. =~/.aspell.en.pws=.


  Alternatively, call flyspell-goto-next-error by pressing =C-,= and
  press =C-c k= to select the correct word from dictionary and write
  it to abbreviations for automatic correction permanently. Adapted
  from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Endless Parentheses]].

   =C-., (flyspell-auto-correct-word)=

   [[https://github.com/tlikonen/wcheck-mode]] is the next level of
   abstraction in spell checking. It can work with standard ispell,
   aspell and hunspell, but also with enchant that can deal with
   languages that have more complex rules of inflection than typical
   Germanic languages. Finnish has a freeware program [[http://voikko.puimula.org/][Voikko]] that can
   deal with its intricacies.
   - http://www.hillenius.com/blog/2013/11/09_writers-need-spell-checkers-wcheck-mode.html
   - https://github.com/philc/emacs-config

   #+NAME: spell-checker
   #+BEGIN_SRC emacs-lisp

     ;; these two sexps set up a functional wcheck
     (setq-default wcheck-language "english")
     (setq-default wcheck-language-data
                   '(("english"
                      (program . "/usr/local/bin/aspell")
                      (args "list") ; -l: list only the mispellings.
                      (face . hi-yellow)
                      (connection . pty)
                      ;; Note that I don't use this functionality of providing suggested spelling corrects, and
                      ;; this config is untested. I just like to highlight mispelled words.
                      (action-program . "/usr/local/bin/aspell")
                      (action-args "-a") ; -a: lists alternatives.
                      (action-parser . wcheck-parser-ispell-suggestions))))



     (defvar my-finnish-syntax-table
       (copy-syntax-table text-mode-syntax-table))
     (modify-syntax-entry ?- "w" my-finnish-syntax-table)
     (setq-default wcheck-language "finnish")

     (setq wcheck-language-data
                   '(("english"
                      (program . "/usr/local/bin/aspell")
                      (args "list") ; -l: list only the mispellings.
                      (face . hi-yellow)
                      (connection . pty)
                      (action-program . "/usr/local/bin/aspell")
                      (action-args "-a") ; -a: lists alternatives.
                      (action-parser . wcheck-parser-ispell-suggestions))
                     ("british"
                      (program . "/usr/local/bin/aspell")
                      (args "list" "-l" "en_BR") ; list: list only the mispellings.
                      (face . hi-yellow)
                      (connection . pty)
                      (action-program . "/usr/local/bin/aspell")
                      (action-args "-a" "-l" "en_BR") ; -a: lists alternatives.
                      (action-parser . wcheck-parser-ispell-suggestions))
                     ("finnish"
                      (program . "/usr/local/bin/enchant")
                      (args "-l" "-d" "fi")
                      (syntax . my-finnish-syntax-table)
                      (action-program . "/usr/local/bin/enchant")
                      (action-args "-a" "-d" "fi")
                      (action-parser . wcheck-parser-ispell-suggestions))
                     ))



     ;; Set aspell as the spell program
     (setq ispell-program-name "aspell")

     ;; Speed up aspell: ultra | fast | normal
     (setq ispell-extra-args '("--sug-mode=ultra"))

     (setq ispell-dictionary "british")

     (let ((langs '( "english" "finnish" "american" )))
       (setq lang-ring (make-ring (length langs)))
       (dolist (elem langs) (ring-insert lang-ring elem)))

     ;;     ("British English"
     ;;      (program . "/usr/local/bin/enchant")
     ;;      (args "-l" "-d" "en_GB")
     ;;      (face . hi-yellow)
     ;;      (connection . pty)
     ;;      (action-program . "/usr/local/bin/enchant")
     ;;      (action-args "-a" "-d" "en_GB")
     ;;      (action-parser . wcheck-parser-ispell-suggestions))))


     (setq wcheck-language-data
           '(("british"
              (program . "/usr/local/bin/aspell")
              (args "-l" "-d" "british")
              (action-program . "/usr/local/bin/aspell")
              (action-args "-a" "-d" "british")
              (action-parser . wcheck-parser-ispell-suggestions))
             ("Finnish"
              (program . "/usr/local/bin/enchant")
              (args "-l" "-d" "fi")
              (syntax . my-finnish-syntax-table)
              (action-program . "/usr/local/bin/enchant")
              (action-args "-a" "-d" "fi")
              (action-parser . wcheck-parser-ispell-suggestions))
             ("cat" ((program . "/bin/cat")))))

     (bind-key "C-c s" 'wcheck-mode)
     (bind-key "C-c l" 'wcheck-change-language)
     (bind-key "C-c c" 'wcheck-actions)
     ;;(bind-key "C-c n" 'wcheck-jump-forward)
     ;;(bind-key "C-c p" 'wcheck-jump-backward)

     (bind-key "C-c w" 'hydra-wcheck/body)
     (defhydra hydra-wcheck (:color pink :hint nil)
       "
        ^Wcheck^             ^Check^      [Language: %`ispell-current-dictionary]
      ^^-----------------------------------------------------------
        _t_: toggle            _n_: next error
        _c_: change language   _k_: correct and add to abbrev
         a   actions           _i_: insert to personal list
        _q_uit                 _u_: insert, uncapitalize and insert
               "
       ("n" flyspell-goto-next-error)
       ("t" cycle-ispell-languages)
       ("q" nil :color blue)

       ("c" ispell-word)
       ("k" my/aspell-word-then-abbrev)
       ("i" my/flyspell-save-word)
       ("u" (my/flyspell-save-word t)))
   #+END_SRC

   #+NAME: spell-checker
   #+BEGIN_SRC emacs-lisp
     (setq ispell-program-name "aspell") ;; checker engine

     ;; Speed up aspell: ultra | fast | normal
     (setq ispell-extra-args '("--sug-mode=ultra"))

     ;; Flyspell activation for text mode
     (add-hook 'text-mode-hook
               (lambda () (flyspell-mode 1)
                 (diminish 'flyspell-mode " ✓")))

     ;; Remove Flyspell from some sub modes of text mode
     (dolist (hook '(change-log-mode-hook
                     log-edit-mode-hook))
       (add-hook hook (lambda () (flyspell-mode -1))))

     ;; switching languages
     ;; code adapted from http://www.emacswiki.org/emacs/FlySpell
     ;; default is 'american'
     (setq ispell-dictionary "american")

     (let ((langs '( "english" "finnish" "american" )))
       (setq lang-ring (make-ring (length langs)))
       (dolist (elem langs) (ring-insert lang-ring elem)))

     (defun cycle-ispell-languages ()
       (interactive)
       (let* ((dict ispell-current-dictionary)
              (lang (ring-ref lang-ring -1)))
         (ring-insert lang-ring lang)
         (ispell-change-dictionary lang)
         (message "Dictionary switched from %s to %s" dict lang)))

     (defun my/aspell-word-then-abbrev (p)
       "Call `ispell-word'. Then create an abbrev for the correction made.
     With prefix P, create local abbrev. Otherwise it will be global."
       (interactive "P")
       (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
         (call-interactively 'ispell-word)
         (setq aft (downcase (or (thing-at-point 'word) "")))
         (unless (string= aft bef)
           (message "\"%s\" now expands to \"%s\" %sally"
                    bef aft (if p "loc" "glob"))
           (define-abbrev
             (if p local-abbrev-table global-abbrev-table)
             bef aft))))

     (bind-key "C-c k" 'my/aspell-word-then-abbrev)

     ;; original copied from
     ;; http://stackoverflow.com/questions/22107182/in-emacs-flyspell-mode-how-to-add-new-word-to-dictionary
     (defun my/flyspell-save-word (&optional save-lowercase)
       "Save word to a personal dictionary.

           The dictionary file depends on the used spell program. If the the first
           argument SAVE-LOWERCASE is non-nil, save also lowercased word.
          "
       (interactive)
       (let ((current-location (point))
             (word (flyspell-get-word)))
         (when (consp word)
           (when (boundp save-lowercase)
               (flyspell-do-correct
                'save nil (downcase (car word)) current-location (cadr word)
                (downcase (caddr word)) current-location))
             (flyspell-do-correct
              'save nil (car word) current-location (cadr word)
              (caddr word) current-location))))

     (setq flyspell-issue-message-flag nil)

     (bind-key "C-x '" 'hydra-flyspell/body)
      (defhydra hydra-flyspell (:color pink :hint nil)
        "
       ^Flyspell^             ^Check^      [Language: %`ispell-current-dictionary]
     ^^-----------------------------------------------------------
       _n_: next error        _c_: correct
       _t_: cycle languages   _k_: correct and add to abbrev
       _q_uit                 _i_: insert to personal list
       ^ ^                    _u_: insert, uncapitalize and insert
     "
        ("n" flyspell-goto-next-error)
        ("t" cycle-ispell-languages)
        ("q" nil :color blue)

        ("c" ispell-word)
        ("k" my/aspell-word-then-abbrev)
        ("i" my/flyspell-save-word)
        ("u" (my/flyspell-save-word t)))
   #+END_SRC

** TODO wcheck mode

  A level up in spell checking abstractions is [[https://github.com/tlikonen/wcheck-mode][Wcheck Mode]] that
  understands programs for proper inflection of words in Finnish in
  addition to standard flyspell.

  Sources:
  - http://www.hillenius.com/blog/2013/11/09_writers-need-spell-checkers-wcheck-mode.html
  - 

  #+NAME: spell-checker_________inactive
  #+BEGIN_SRC emacs-lisp

    (setq ispell-program-name "aspell")

    (defvar my-finnish-syntax-table
      (copy-syntax-table text-mode-syntax-table))

    (modify-syntax-entry ?- "w" my-finnish-syntax-table)

    (setq wcheck-language-data
          '(("British English"
             (program . "/usr/local/bin/aspell")
             (args "-a"  "-l" "-d" "british")
             (action-program . "/usr/local/bin/aspell")
             (action-args "-a" "-d" "british")
             (action-parser . wcheck-parser-ispell-suggestions))
            ("Finnish"
             (program . "/usr/bin/enchant")
             (args "-l" "-d" "fi")
             (syntax . my-finnish-syntax-table)
             (action-program . "/usr/bin/enchant")
             (action-args "-a" "-d" "fi")
             (action-parser . wcheck-parser-ispell-suggestions))))
  #+END_SRC

** iedit mode

   Activate the [[http://www.emacswiki.org/emacs/Iedit][Iedit]] mode by placing the cursor to a word and
   pressing =C-x t i=. All occurrences of that word in the buffer are
   selected and can be simultaneously edited.

** Count words in a buffer

  #+name: text-files
  #+BEGIN_SRC emacs-lisp
        ;; word-count
        (defun word-count nil "Count words in buffer" (interactive)
          (shell-command-on-region (point-min) (point-max) "wc -w"))

    (defun count-words (start end)
      "Print number of words in the region."
      (interactive "r")
      (save-excursion
        (save-restriction
          (narrow-to-region start end)
          (goto-char (point-min))
          (count-matches "\\sw+"))))
  #+END_SRC

** Text editing done by external programs

  It used to be quicker for me to write perl scripts to format text than
  do it any other way. These functions demonstrate how a standard command
  line program that reads from STDIN and write to STDOUT is easily
  included into emacs workflow. Markdown and SmartyPants are equally
  antiquated functions.

  Programs need to be available in your shell path. I most often use
  [[http://gist.github.com/heikkil/7510734][txt2para.pl]] that serves as a good example of these programs.

  #+name: text-files
  #+BEGIN_SRC emacs-lisp

    (defun txt2xhtml ()
      "Turn consecutive non-empty lines of plain text into HTML <p> elements."
      (interactive)
      (shell-command-on-region (point)
             (mark) "txt2xhtml.pl" nil t))

    (defun txt2header ()
      "Turn consecutive non-empty lines of plain text into HTML <h2> elements."
      (interactive)
      (shell-command-on-region (point)
             (mark) "txt2header.pl" nil t))

    (defun txt2para ()
      "Turn consecutive non-empty lines of plain text into paragraphs."
      (interactive)
      (shell-command-on-region (point)
             (mark) "txt2para.pl" nil t))

    (defun do-mark-down (start end)
       "Invoke the Markdown algorithm on region."
       (interactive "r")
       (shell-command-on-region start end "Markdown.pl" t t))
     ;;(global-set-key "\C-cm" 'do-mark-down)

    (defun do-smarty-pants (start end)
       "Invoke the SmartyPants algorithm on region."
       (interactive "r")
       (shell-command-on-region start end "SmartyPants.pl" t t))
     ;;(global-set-key "\C-cs" 'do-smarty-pants)
  #+END_SRC

** Commenting

   The default emacs line commenting leaves a lot of things out. A
   replacement package [[https://github.com/remyferre/comment-dwim-2][comment-dwim-2]] allows uncommenting and cycling
   of different behaviors. The default comment key is =C-;=.

   Note to self: [[https://github.com/redguardtoo/evil-nerd-commenter][evil-nerd-commenter]] is recommended for the evil mode.

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     (use-package comment-dwim-2
       :bind "M-;")
   #+END_SRC

   Remember: =C-x ;= sets the comment column (comment-set-column)

** Editing as root

  If you open a file that you do not have permissions to edit, you can
  call this function =edit-current-file-as-root= to invoke sudo rights
  within emacs. Kudos to [[http://wenshanren.org/?p=298][Wenshan]].

  #+name: global-navigation
  #+BEGIN_SRC emacs-lisp
    (defun edit-current-file-as-root ()
      "Edit as root the file associated with the current buffer"
       (interactive)
       (if (buffer-file-name)
           (progn
             (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
             (find-file file))
         (message "Buffer is not associated to a file.")))
   #+END_SRC

** Editing file lists with wdired

   [[http://www.masteringemacs.org/articles/2013/10/10/wdired-editable-dired-buffers/][Editable dired]] is part of standard emacs. Once you are in dired
   =C-x d=, directory editing, mode, you can press =C-x C-q= to edit
   file names like any text. The familiar =C-c C-c= commits the
   changes.

  #+name: global-navigation
  #+BEGIN_SRC emacs-lisp
    ;;http://mbork.pl/2015-04-25_Some_Dired_goodies
    ;;
    ;; file type association to a program
    (setq dired-guess-shell-alist-user
          '(("\\.pdf\\'" "skim")
            ("\\.tex\\'" "pdflatex")
            ("\\.ods\\'\\|\\.xlsx?\\'\\|\\.docx?\\'\\|\\.csv\\'" "libreoffice")))
    ;; open a file replacing the current dired buffer
    (put 'dired-find-alternate-file 'disabled nil)
  #+END_SRC

** Image mode

   Recent emacsen can show images in directly in buffers. The
   following code adds the [[https://github.com/mhayashi1120/Emacs-imagex][image+]] minor mode to any image buffer and
   scales the picture to the current frame.

  #+name: global-navigation
  #+BEGIN_SRC emacs-lisp
    (use-package image
      :config
      (use-package image+
        :ensure t
        :config (imagex-auto-adjust-mode 1)))
   #+END_SRC

** Macros

   Emacs has a powerful [[http://www.emacswiki.org/emacs/KeyboardMacros][keyboard macro]] system. However, it has its own
   internal notation. The [[https://github.com/Silex/elmacro][elmacro]] minor mode converts these macros into
   emacs lisp functions. Start elmacro mode (=M-x elmacro-mode=)
   before recording the macro, and once it has been defined, use =M-x
   elmacro-show-last-macro= to give the function a name, and see it in
   a new buffer.

   The function key shortcuts for macros are not useful under OS X,
   but these commands work well:

   - =C-x (= kmacro-start-macro
   - =C-x )= kmacro-end-macro
   - =C-x e= kmacro-end-and-call-macro
   - =e= call macro if pressed right after previous function
   - =C-u n C-x e= run the macro n times
   - =C-x C-k C-e= edit last macro

** Buffers

   A more functional buffer listing comes from =ibuffer=. The
   following makes normal =list-buffer= or =C-x C-b= call ibuffer. Check
   the new menu lists Operate, View and Mark.

  #+name: global-navigation
  #+BEGIN_SRC emacs-lisp
    (defalias 'list-buffers 'ibuffer) ; make ibuffer default
  #+END_SRC

* Version control

** Magit

  The only version control system worth using is git and [[http://magit.github.io/magit/magit.html][magit]] is the
  emacs interface to it. Most important files in git have their
  dedicated modes: git-commit-mode, gitconfig-mode, git-rebase-mode,
  and gitignore-mode.

  From any buffer linked to git controlled file, press =C-c g= to
  enter magit status window. Pressing =q= restores the previous
  window(s).

  Magit automatically updates the buffer of each file that changes at
  commit. I do not have to see the default /MRev/ mode line indicator.

  See [[http://shingofukuyama.github.io/emacs-magit-reword-commit-messages/][this post]] for a tutorial of commit message editing with magit.

  #+name: version-control
  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :bind ("C-c g" . magit-status)
      :config
      (setq magit-diff-options '("-b")) ; ignore whitespace
      ;; full screen magit-status
      (defadvice magit-status (around magit-fullscreen activate)
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))

      (defun magit-quit-session ()
        "Restores the previous window configuration and kills the magit buffer"
        (interactive)
        (kill-buffer)
        (jump-to-register :magit-fullscreen))

      ;; hide MREv mode line indicator
      (add-hook 'magit-status-mode-hook
                (lambda () (diminish 'magit-auto-revert-mode))))
  #+END_SRC

** git-timemachine

  [[https://github.com/pidu/git-timemachine][git-timemachine]] lets you browse previous versions of a file. Start
  it with =C-x l t= or =C-x git-timemachine=.

  | key | description                 |
  |-----+-----------------------------|
  | p   | visit previous version      |
  | n   | visit next version          |
  | w   | copy the short version hash |
  | W   | copy the full version hash  |
  | q   | quit                        |

* Text files
** Writing style

   [[https://github.com/bnbeckwith/writegood-mode][Writegood mode]], =C-x t w=, highlights common writing problems in
   English text. It highlights weasel words, passive voice, and
   duplicate words. Additionally, it can show [[http://en.wikipedia.org/wiki/Flesch%E2%80%93Kincaid_readability_tests][Flesch-Kincaid scoring
   and grade-level estimates]].

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     (use-package writegood-mode
       :bind
       ("C-c C-g g" . writegood-grade-level)
       ("C-c C-g e" . writegood-reading-ease))
   #+END_SRC

   *Do not require languagetool!* Version 2.8 spans huge amount of
   java processes that causes the system to grind to a halt.

   ##+name: text-files
   #+BEGIN_SRC emacs-lisp
     (use-package languagetool-mode
       :disabled t
       :bind (("C-x 4 w" . langtool-check)
              ("C-x 4 W" . langtool-check-done)
              ("C-x 4 l" . langtool-switch-default-language)
              ("C-x 4 4" . langtool-show-message-at-point)
              ("C-x 4 c" . langtool-correct-buffer))
       :init
       (setq languagetool-language-tool-jar
             "/usr/local/Cellar/languagetool/2.8/libexec/languagetool-commandline.jar")
       (setq languagetool-disabled-rules '("WHITESPACE_RULE"
                                           "EN_UNPAIRED_BRACKETS"
                                           "COMMA_PARENTHESIS_WHITESPACE"
                                           "EN_QUOTES")))
   #+END_SRC

** Whitespace

   [[http://ergoemacs.org/emacs/whitespace-mode.html][Whitespace mode]] makes whitespace characters visible in a buffer.
   This tones down the colors and uses good looking Unicode characters.
   Toggle it with "Emacs, toggle (white)Space" =C-x t s=.

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     ;; make whitespace-mode use just basic coloring

     (setq whitespace-style
           (quote (face spaces tabs newline space-mark tab-mark newline-mark trailing)))
     ;; use better unicode characters for whitespace
     (setq whitespace-display-mappings
           ;; all numbers are Unicode codepoint in decimal. try (insert-char 182 ) to see it
           '((space-mark 32 [183] [46]) ; 32 SPACE, 183 MIDDLE DOT 「·」, 46 FULL STOP 「.」
             (newline-mark 10 [182 10]) ; 10 LINE FEED
             (tab-mark 9 [9655 9] [92 9]) ; 9 TAB, 9655 WHITE RIGHT-POINTING TRIANGLE 「▷」
             ))
   #+END_SRC

** Line numbers

   Line numbers are useful in pair programming and when editing with
   modal commands like evil mode. To help working with evil, I display
   line numbers display relative to the current line.

   I wrapped this in a global minor mode so turning that stuff on and
   off is easy using =C-x t l=.

   My fingers still know this old shortcut for jumping to a line
   number. The function =goto-line-with-feedback= automatically turns
   line numbers on and shows them in normal mode for the duration of
   the command. It assumes that line numbers are off to start with.

   #+name: programming-setup
   #+BEGIN_SRC emacs-lisp
     (use-package linum-relative
       :init
       ;; show absolute line number for the current line
       (setq linum-relative-current-symbol ""))

     (define-minor-mode my/linum-mode
     "Toggle showing of line numbers.

     Interactively with no argument, this command toggles the mode.  A
     positive prefix argument enables the mode, any other prefix
     argument disables it.  From Lisp, argument omitted or nil enables
     the mode, `toggle' toggles the state."
       nil           ; The initial value.
       nil           ; The indicator for the mode line
       '()           ; The minor mode bindings.
       :group 'my/linum
       (linum-mode (if my/linum-mode 1 -1)))

     (define-global-minor-mode my/global-linum-mode
       my/linum-mode
       (lambda () (my/linum-mode 1)))

     (defun goto-line-with-feedback ()
       "Show line numbers temporarily, while prompting for the line number input"
       (interactive)
       (unwind-protect
           (progn
             (linum-relative-toggle)
             (linum-mode 1)
             (goto-line (read-number "Goto line: ")))
         (linum-mode -1)
         (linum-relative-toggle)))

     (bind-key "C-x ," 'goto-line)
     (bind-key [remap goto-line] 'goto-line-with-feedback)
   #+END_SRC

** LaTeX

   Use AUCTex for all LaTeX. There is an extensive info documentation
   that you do not read to get started =C-h i m auctax=.

   [[https://github.com/Bruce-Connor/latex-extra][LaTeX-extra]] gives additional features like code folding. The
   AUXTeX-latexmk package uses the latexmk to compile. Set it to
   produce PDF by running the following code block:

   #+BEGIN_SRC sh
     cat > ~/.latexmkrc
     # .latexmkrc starts
     $pdf_mode = 1;
     # .latexmkrc ends
  #+END_SRC

   [[http://www.emacswiki.org/emacs/LaTeXPreviewPane][latex-preview-panel]] package enables preview within Emacs. I could
   add =(latex-preview-panel-enable)= here but it I can enable it on
   the fly with =M-x latex-preview-pane-mode=

   [[http://endlessparentheses.com/longlines-mode-in-latex.html][Endless Parentheses]] tackles long lines by modifying the longlines
   mode to make emacs more compatible with other LaTeX editors.
   [[http://stackoverflow.com/questions/13559061/emacs-how-to-keep-the-indentation-level-of-a-very-long-wrapped-line][StackExchange]] gives a solution below using the package adaptive-wrap.

   My LaTeX setup wraps long lines at the word boundary on window edge
   (visual-line-mode on) and prevents automatic word wrapping using
   hard newlines (auto-fill-mode off) when buffer is in LaTeX mode.
   This is exactly opposite to behaviors in most other text modes.

   Hit =C-c C-c= to compile, =C-c C-v= to view.

   More [[http://piotrkazmierczak.com/2010/05/13/emacs-as-the-ultimate-latex-editor/][AUCTeX]] tips. [[http://irreal.org/blog/?p=3577][Irreal blog]].

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
    (auctex-latexmk-setup)
    (add-hook 'LaTeX-mode-hook #'latex-extra-mode)

     (when (fboundp 'adaptive-wrap-prefix-mode)
       (defun my-activate-adaptive-wrap-prefix-mode ()
         "Toggle `visual-line-mode' and `adaptive-wrap-prefix-mode' together,
               and auto-fill-mode the opposite way."
         (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1))
         (auto-fill-mode (if visual-line-mode -1 1)))
       (add-hook 'visual-line-mode-hook 'my-activate-adaptive-wrap-prefix-mode))

     (setq TeX-auto-save t)
     (setq TeX-parse-self t)
     (setq-default TeX-master nil)           ;
     (setq reftex-plug-into-AUCTeX t)        ;
     (setq TeX-PDF-mode t)                   ; default processing to pdflatex
     (setq TeX-electric-sub-and-superscript t) ;Inserts {} automatically on _ and ^
     (setq TeX-save-query nil)               ; always save without asking when compiling

     ;; remove auto-fill
     (defun my/latex-hooks ()
       (my/turn-on 'visual-line         ; now turns off auto-fill
                   'flyspell))
     (add-hook 'latex-mode-hook 'my/latex-hooks) ; needs testing!!!
     (add-hook 'latex-mode-hook 'turn-on-reftex) ; no -mode in the end

     ;; spell checking on LaTeX buffers
     (add-hook 'latex-mode-hook 'flyspell-mode)
     (add-hook 'latex-mode-hook 'flyspell-buffer)
   #+END_SRC

** XML

    I am using the builtin nXML mode for XML editing and turning off
    automatic line wrapping.

    #+name: text-files
    #+BEGIN_SRC emacs-lisp
     (defun my/nXML-hooks ()
       (auto-fill-mode -1))

     (add-hook 'nXML-mode-hook 'my/nXML-hooks)
    #+END_SRC

** Zsh and fish

   [[http://www.zsh.org/][Zsh]] is a command line shell that is a superset of Bash. Tell emacs
   that its =*.zsh= config files are shell scripts. I use the [[https://github.com/sorin-ionescu/prezto][pretzo]]
   configuration framework for it.

   [[http://fishshell.com/][Fish]], Friendly Interactive SHell, is faster and cleaner than Zsh,
   It is now my main interective shell. I use [[https://github.com/bpinto/oh-my-fish][Oh My Fish!]] management
   framework for it. We need to tell emacs that =*.load= configuration
   files are shell scripts that need =fish-mode=.

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     (use-package fish-mode
       :mode ("\\.load$'" "\\.zsh$"))
   #+END_SRC

** NEURON

   NEURON is a high level programming language for computational
   neurologybiology. Unless you are in the field, you will not need
   these modes. If you do, download the =.el= files and add them into
   your custom elisp directory (see section [[Custom lisp package
   directory]]).

   #+name: text-files
   #+BEGIN_SRC emacs-lisp
     ;;
     ;; NEURON hoc and mod files
     ;;
     ;; see: http://www.sterratt.me.uk/progs/neuron/
     ;; wget http://www.sterratt.me.uk/sites/sterratt.me.uk/files/nrnhoc.el
     ;; wget http://www.sterratt.me.uk/sites/sterratt.me.uk/files/nmodl.el

     (autoload 'nrnhoc-mode "nrnhoc" "Enter NRNHOC mode." t)
     (setq auto-mode-alist (cons '("\\.hoc\\'" . nrnhoc-mode) auto-mode-alist))
     ;; (add-hook 'nrnhoc-mode-hook 'turn-on-font-lock)

     (autoload 'nmodl-mode "nmodl" "Enter NMODL mode." t)
     (setq auto-mode-alist (cons '("\\.mod\\'" . nmodl-mode) auto-mode-alist))
   #+END_SRC

** MarkDown

   Github and especially BitBucket use =markdown mode= for
   documentation, so my Emacs knows about it. GitHub knows how to
   render =org-mode= documents, too, so this mode is not getting much
   use.

   My =org-mode= is configured to export to markdown format.

 #+name: text-files
  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
          :mode  ("\\.md" "\\.markdown"))
  #+END_SRC

** Ledger

   Ledger is a command line accounting program with strong emacs
   support.

   The following tells ledger to use ISO dates and sets some default
   reports. There does not seem to be consensus on ledger file
   extension. I am using =led=.

   The ledger mode has been getting a lot of bug fixes recently. These
   changes are affecting font coloring, too. Many of the font faces
   are inherited which are good in principle, but at the moment they
   clash badly. I try to set them back to somewhat calmer palette.

  #+name: text-files
  #+BEGIN_SRC emacs-lisp
    (autoload 'ledger-mode "ledger-mode.el"
      "Major mode for editing Ledger files" t)
    (setq auto-mode-alist
          (cons '("\\.led" . ledger-mode) auto-mode-alist))

    (defun my/ledger-mode-hooks ()
      "Ledger mode settings"
      ;; date format
      (setq ledger-use-iso-dates t)
      ;; font changes
      ;;(setq ledger-font-comment-face ((t (:foreground "dark gray"))))
      (set-face-attribute 'ledger-font-comment-face nil :foreground "gray40")
      (set-face-attribute 'ledger-occur-xact-face nil :inherit t :background "cornsilk")
      ;; use flycheck
      (flycheck-mode)
      ;; reports
      (setq ledger-reports
            (quote (("test" "ledger ")
                    ("bal" "ledger -f %(ledger-file) bal")
                    ("reg" "ledger -f %(ledger-file) reg")
                    ("payee" "ledger -f %(ledger-file) reg @%(payee)")
                    ("account" "ledger -f %(ledger-file) reg %(account)")))))

    (add-hook 'ledger-mode-hook
              'my/ledger-mode-hooks)

    ;; flycheck-ledger does syntax checking
    ;;(eval-after-load 'ledger-mode '(require 'flycheck-ledger))
  #+END_SRC

** Ssh config

   Ssh-config-mode highlights valid keys in ssh configuration files.

  #+name: text-files
#+BEGIN_SRC emacs-lisp
  (autoload 'ssh-config-mode "ssh-config-mode" t)
  (add-to-list 'auto-mode-alist '(".ssh/config\\'"       . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("sshd?_config\\'"      . ssh-config-mode))
  (add-to-list 'auto-mode-alist '("known_hosts\\'"       . ssh-known-hosts-mode))
  (add-to-list 'auto-mode-alist '("authorized_keys2?\\'" . ssh-authorized-keys-mode))
  (add-hook 'ssh-config-mode-hook 'turn-on-font-lock)
#+END_SRC

* Programming

   This applies to any scripting language file that starts with a
   shebang: the code make those files executable on saving.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-save-hook
               'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC

** Perl

   I recently moved from [[http://perlbrew.pl/][perlbrew]] to [[https://github.com/tokuhirom/plenv][plenv]] as a system that provides
   user controlled perl environment that is separate from vendor
   perl.

   For OS X, install plenv with =brew install plenv; brew install
   perl-build= and install your favorite version of perl and put into
   =plenv-global= below.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (use-package plenv
       :config
       (condition-case nil
           (plenv-global "5.20.1")
         (error (message "ERROR: unknown perl version. Is your plenv configured right?"))))
   #+END_SRC

   Use the built-in =cperl-mode= instead of the default =perl-mode=

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (use-package cperl-mode
       :mode "\\.\\([pP][Llm]\\|al\\)\\'"
       :interpreter ("perl" "perl5" "miniperl")
       :config
       (defun n-cperl-mode-hook ()
         (setq cperl-indent-level 4
               cperl-close-paren-offset -4
               cperl-continued-statement-offset 4
               cperl-indent-parens-as-block t
               cperl-tab-always-indent t)
         (my/turn-on 'show-paren-mode
                     'aggressive-indent-mode
                     'flyspell-prog-mode))
       (add-hook 'cperl-mode-hook 'n-cperl-mode-hook t))
   #+END_SRC

   Call perltidy with =C-c t= from emacs to indent and beautify perl
   code in the current buffer. This code calls the command line
   [[http://metacpan.org/author/SHANCOCK][perltidy]] utility that is part of [[http://metacpan.org/pod/Perl::Tidy][Perl::Tidy]] CPAN module.

   The =C-c t= key for perltidy is defined in the most efficient way:
   the code is loaded only once when the cperl-mode is first called.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
      (defun perltidy ()
         "Run perltidy on the current region or buffer."
         (interactive)
         ; Inexplicably, save-excursion doesn't work here.
         (let ((orig-point (point)))
           (unless mark-active (mark-defun))
           (shell-command-on-region (point) (mark) "perltidy -q" nil t)
           (goto-char orig-point)))

     (eval-after-load 'cperl-mode
       '(bind-key  "C-c t" 'perltidy cperl-mode-map))

   #+END_SRC

*** TODO Call =pod-mode= on POD documentation files and enable spell checking.

    #+NAME: programming-setup
    #+BEGIN_SRC emacs-lisp
     (autoload 'pod-mode "pod-mode"
       "Mode for editing POD files" t)
     (add-to-list 'auto-mode-alist '("\\.pod$" . pod-mode))
     (add-hook 'pod-mode-hook 'font-lock-mode)

     (add-hook 'pod-mode-hook '(lambda ( )
                                 (progn (font-lock-mode)   ; =syntax highlighting
                                        (auto-fill-mode 1) ; =wordwrap
                                        (flyspell-mode 1)  ; =spellchecking
                                        )))
    #+END_SRC

** Lisps

   For lisp code, I want ParEdit and realtime "aggressive" indenting.
   ElDoc shows arguments to function under cursor.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (setq my/lisps
           '(emacs-lisp lisp clojure))

     (defun my/general-lisp-hooks ()
       (my/turn-on 'paredit
                   ;;'rainbow-delimiters
                   'show-paren-mode
                   'aggressive-indent-mode
                   'eldoc
                   ;;'highlight-parentheses
                   ))
     (dolist (mode (mapcar 'my/->mode-hook my/lisps))
       (add-hook mode
                 'my/general-lisp-hooks))
   #+END_SRC

   The most useful paredit key combinations use =C-<arrow>= that are
   taken by OS X to switch between desktops. Use the Cmd key (s for
   super in emacs), instead.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (use-package paredit
       :if (eq system-type 'darwin)
       :no-require t
       :config
       ;; C-left
       (bind-key "s-<left>" 'paredit-forward-barf-sexp paredit-mode-map)
       ;; C-right
       (bind-key"s-<right>" 'paredit-forward-slurp-sexp paredit-mode-map)
       ;; Alt-C-left
       (bind-key "M-s-<left>" 'paredit-backward-slurp-sexp paredit-mode-map)
       ;; Alt-C-right
       (bind-key"M-s-<right>" 'paredit-backward-barf-sexp paredit-mode-map))
   #+END_SRC

   In my emacs lisp programming I am using the *Names* package that
   enables namespaces. The following sets debugging tools up to
   recognize these namespaces:

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (use-package names-dev)
   #+END_SRC

   Now that I am using =use-package= macro to configure packages, it
   is useful to see what the configuration macro actually does.
   [[https://github.com/joddie/macrostep][Macrostep]] package defines keys to expand and collapse macros one
   level at a time. Run =macrostep-expand= with =C-c m=.

   | Keys       | Description           |
   |------------+-----------------------|
   | e, =, RET  | expand                |
   | c, u, DEL  | collapse              |
   | q, C-c C-c | collapse all and exit |
   | n, TAB     | next macro            |
   | p, M-TAB   | previous macro        |

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (use-package macrostep
       :bind ("C-c m" . macrostep-expand))
   #+END_SRC

** Clojure

   I'm using [[https://github.com/clojure-emacs/cider/commits/master][CIDER]] for clojure source/repl interaction. Start it with
   incantation "Emacs, launch cider" =C-x l c=.

   Cider installation requires that the current version =M-x
   cider-version=is passed through leiningen to clojure. Minimal
   =~/.lein/profiles.clj= file:

   #+BEGIN_EXAMPLE
   {:user {:plugins [[cider/cider-nrepl "0.9.0-SNAPSHOT"]]}}
   #+END_EXAMPLE

   I treat the REPL mode specially, since certain hooks that work in
   ~clojure-mode~ won't make sense or break functionality in
   ~cider-repl-mode~.

   Meta-up and -down to move in the REPL history are taken by paredit,
   so I bind the functions to Command (Super) key: =s-up>= and
   =s-down=.

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     (use-package cider
       :config
       (defun my/cider-mode-hooks ()
         "Clojure specific setup code that should only be run when we
       have a CIDER REPL connection"
         (setq nrepl-log-messages t)
         (setq nrepl-hide-special-buffers t))

       (add-hook 'cider-mode-hook
                 'my/cider-mode-hooks)

       (defun my/cider-repl-mode-hooks ()
         (my/turn-on 'paredit
                     ;;'rainbow-delimiters
                     'show-paren-mode
                     'highlight-parentheses))

       (add-hook 'cider-repl-mode-hook
                 'my/cider-repl-mode-hooks)

       ;; M-up -> s-up
       (bind-key "s-<up>" 'cider-repl-previous-input cider-repl-mode-map)
       ;; M-down -> s-down
       (bind-key "s-<down>" 'cider-repl-next-input cider-repl-mode-map))

   #+END_SRC

** TODO Python

   Python setup is [[https://github.com/ikame/.emacs.d/blob/master/setup-python.org][copied from here]]. Work in progress.

   First make sure you have installed your python dependencies runtime
   environment:

   #+BEGIN_SRC sh
     pip install elpy
     pip install rope
     pip install jedi
   #+END_SRC

   ##+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp

     (add-to-list 'auto-mode-alist '("/requirements\\.txt\\'" . conf-mode))

     ;;     (use-package python-mode
     ;;       :mode ("\\.py\\'" . python-mode)
     ;;       :interpreter ("python" . python-mode)
     ;;       :config
     ;;       (progn
     ;;         (defvar python-mode-initialized nil)
     ;; 
     ;;         (defun my-python-mode-hook ()
     ;;           (unless python-mode-initialized
     ;;             (setq python-mode-initialized t)
     ;; 
     ;;             (info-lookup-add-help
     ;;              :mode 'python-mode
     ;;              :regexp "[a-zA-Z_0-9.]+"
     ;;              :doc-spec
     ;;              '(("(python)Python Module Index" )
     ;;                ("(python)Index"
     ;;                 (lambda
     ;;                   (item)
     ;;                   (cond
     ;;                    ((string-match
     ;;                      "\\([A-Za-z0-9_]+\\)() (in module \\([A-Za-z0-9_.]+\\))" item)
     ;;                     (format "%s.%s" (match-string 2 item)
     ;;                             (match-string 1 item)))))))))
     ;; 
     ;;           (setq indicate-empty-lines t)
     ;;           (set (make-local-variable 'parens-require-spaces) nil)
     ;;           (setq indent-tabs-mode nil)
     ;; 
     ;;           (bind-key "C-c C-z" 'python-shell python-mode-map)
     ;;           (unbind-key "C-c c" python-mode-map))
     ;; 
     ;;         (add-hook 'python-mode-hook 'my-python-mode-hook)))


     (defun my/setup-python-mode ()
       "Custom command to setup python-mode"
       (interactive)
       (let ((max-column 99))
         (setq python-shell-interpreter "/Users/lehvasho/miniconda3/bin/python"
               python-shell-interpreter-args "-i"
               ;;venv-location "~/.virtualenvs"
               whitespace-line-column max-column
               fill-column max-column
               flycheck-flake8-maximum-line-length max-column
               elpy-rpc-backend "jedi"
               ;;elpy-rpc-backend "rope"
               ;;elpy-default-minor-modes '(eldoc-mode)
               elpy-rpc-project-specific t))
       (setq python-indent-offset 4)
       (setq jedi:complete-on-dot t)
       (flycheck-mode)
       ;;(pyenv-mode)
       ;;(add-hook 'focus-out-hook 'save-buffer)
       ;;(highlight-lines-matching-regexp "import i?pdb")
       ;;(highlight-lines-matching-regexp "i?pdb.set_trace()")
       (turn-on-fci-mode)  ; fill-column-indicator
       (elpy-enable)
       ;;(elpy-mode)
       ;;(elpy-clean-modeline)
       (highlight-indentation-mode))

     (add-hook 'python-mode-hook 'my/setup-python-mode)
     (add-hook 'python-mode-hook 'jedi:ac-setup)
     (add-hook 'python-mode-hook (lambda ()
                                   (use-package sphinx-doc
                                     :config
                                     (sphinx-doc-mode t))))
   #+END_SRC

   [[https://github.com/naiquevin/sphinx-doc.el][Sphinx-doc]] adds a function inserting docstring skeleton for Python
   functions and methods. Inside a Python file move the cursor to some
   function/method definition and hit =C-c M-d=.

** C++

   #+NAME: programming-setup
   #+BEGIN_SRC emacs-lisp
     ;; Use the GDB visual debugging mode
     (setq gdb-many-windows t)
     ;; Turn Semantic on
     (semantic-mode 1)
     ;; Try to make completions when not typing
     (global-semantic-idle-completions-mode 1)
     ;; Use the Semantic speedbar additions
     (add-hook 'speedbar-load-hook (lambda () (use-package semantic/sb)))
     ;; Treat .h files as C++ files (instead of C)
     (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
     ;; Run compile when you press F5
     ;;(global-set-key (kbd "<f5>") 'compile)
   #+END_SRC

* Auto Complete

  Getting auto completion to work right tends to be a messy process of
  trial and error, though in recent years the situation has improved,
  with =auto-complete= mode being more or less the /de facto/ standard.

  - Fuzzy matching might work in unexpected ways.

  #+NAME: auto-complete
  #+BEGIN_SRC emacs-lisp
    (use-package fuzzy
      :defer t)

    (use-package auto-complete
      :init (setq ac-auto-show-menu t
                  ac-quick-help-delay 0.5
                  ac-use-fuzzy t)
      :config (global-auto-complete-mode +1))
  #+END_SRC

* Navigation
** TRAMP mode

   TRAMP mode allows opening remote files. It knows about ssh and
   aliases defined in the ssh config file. You can even use tab completion.
   Setting the default method frees you from typing it. Just open
   file, give '/', and start typing the name of the remote computer.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (setq tramp-default-method "ssh")
   #+END_SRC

** Local navigation in a buffer

   Delete a word at a time: =M-backspace=.

   Kill line backward from cursor is =C-0 C-k= but it easier to
   remember when redefined as =C-backspace=.

   #+name: local-navigation
   #+BEGIN_SRC emacs-lisp
     (bind-key "C-<backspace>"
               #'(lambda () (interactive)
                   (kill-line 0)))
   #+END_SRC

   The most complex replace key combination made little bit easier to
   remember:

   #+name: local-navigation
   #+BEGIN_SRC emacs-lisp
    (defalias 'qrr 'query-replace-regexp)  ; M-C-S %
   #+END_SRC

   Folding uses =set-selective-display= to show a high level
   outline of you document. Useful to get an [[http://emacs.wordpress.com/2007/01/16/quick-and-dirty-code-folding/][overview of long code
   documents]]. Launch it with =C-x t f=.

   #+name: local-navigation
   #+BEGIN_SRC emacs-lisp
    ;; folding of code
    ;; http://emacs.wordpress.com/2007/01/16/quick-and-dirty-code-folding/
    (defun toggle-selective-display ()
      (interactive)
      (set-selective-display (if selective-display nil 1)))
   #+END_SRC

   Key =M-j= joins the next line with the current one. Copied from
   [[http://whattheemacsd.com/key-bindings.el-03.html][WhatTheEmacs!?]] The is an alternative to =M-^= or =C-c q= for
   joining current line to previous one. Unfortunately it does not
   work in org-mode that overrides it.

   #+name: local-navigation
   #+BEGIN_SRC emacs-lisp
     (bind-key  "M-j"  #'(lambda () (interactive) (join-line -1)))
     (bind-key "C-c q" 'delete-indentation)
   #+END_SRC

   When editing indented text, you seldom want to go to the first
   column of the line. Instead the following modifies =C-a= to move
   point back to indentation of beginning of line. Copied from [[ http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][EmacsRedux]].

   Move point to the first non-whitespace character on this line.  If
   point is already there, move to the beginning of the line.
   Effectively toggle between the first non-whitespace character and
   the beginning of the line.

   #+name: local-navigation
   #+BEGIN_SRC emacs-lisp
     (defun smarter-move-beginning-of-line (arg)
       "Move point back to indentation of beginning of line.

       Move point to the first non-whitespace character on this line.
       If point is already there, move to the beginning of the line.
       Effectively toggle between the first non-whitespace character and
       the beginning of the line.

       If ARG is not nil or 1, move forward ARG - 1 lines first.  If
       point reaches the beginning or end of the buffer, stop there."
       (interactive "^p")
       (setq arg (or arg 1))

       ;; Move lines first
       (when (/= arg 1)
         (let ((line-move-visual nil))
           (forward-line (1- arg))))

       (let ((orig-point (point)))
         (back-to-indentation)
         (when (= orig-point (point))
           (move-beginning-of-line 1))))

     ;; remap C-a to `smarter-move-beginning-of-line'
     (bind-key [remap move-beginning-of-line]
               'smarter-move-beginning-of-line)

   #+END_SRC

** Projects

   [[https://github.com/bbatsov/projectile][Projectile]] automatically defines a project for any git repository.
   It indexes files and makes it possible to search files and contents
   within a project. See it's list of commands with =C-c p ?=

#+name: local-navigation
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :defer t
    :diminish projectile-mode
    :init
    (setq projectile-file-exists-remote-cache-expire nil)
    :config
    (projectile-global-mode))
#+END_SRC

** Narrowing

   Narrowing is a way for emacs to hide part of the buffer so that
   only visible parts can be viewed *and edited*. This has the
   potential to be so confusing to an unsuspecting user that this
   feature is disabled by default. It has to be explicitly turned on.

   #+name: local-navigation
   #+BEGIN_SRC emacs-lisp
     (put 'narrow-to-region 'disabled nil)
   #+END_SRC

   [[http://emacs-fu.blogspot.com/2010/08/narrowing-buffer-contents.html][Emacs-Fu]] has a well written article on narrowing. [[http://www.emacswiki.org/emacs/BasicNarrowing][EmacsWiki]] is worth
   checking for caveats.

   | Visible | Function            | Binding |
   |---------+---------------------+---------|
   | region  | (narrow-to-region)  | C-x n n |
   | subtree | (narrow-to-subtree) | C-x n s |
   | all     | (widen)             | C-x n w |

   The Endless Parentheses blog defines function how to [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][toggle narrow
   and widen]]. You just do the incantation "Emacs, toggle narrowing"
   by pressing =C-x t n=!

   #+name: local-navigation
   #+BEGIN_SRC emacs-lisp

     (defun narrow-or-widen-dwim (p)
       "If the buffer is narrowed, it widens. Otherwise, it narrows intelligently.
     Intelligently means: region, org-src-block, org-subtree, or defun,
     whichever applies first.
     Narrowing to org-src-block actually calls `org-edit-src-code'.

     With prefix P, don't widen, just narrow even if buffer is already
     narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((region-active-p)
              (narrow-to-region (region-beginning) (region-end)))
             ((derived-mode-p 'org-mode)
              ;; `org-edit-src-code' is not a real narrowing command.
              ;; Remove this first conditional if you don't want it.
              (cond ((org-in-src-block-p)
                     (org-edit-src-code)
                     (delete-other-windows))
                    ((org-at-block-p)
                     (org-narrow-to-block))
                    (t (org-narrow-to-subtree))))
             (t (narrow-to-defun))))
   #+END_SRC

** DocView

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html#Document-View][DocView]] is for displaying PDF and other document files. It works by
creating an PNG image for each page of the document. Arrow keys work
within a page. Pressing =n= or =<SPC>= moves forward, and =p= or
=<DEL>= change the page. I set the mouse wheel to scroll over pages,
too.

#+name: local-navigation
#+BEGIN_SRC emacs-lisp
  (setq doc-view-continuous nil)
#+END_SRC

#+END_SRC
** Navigation between windows and frames

   Here I boost standard window splitting commands according
   [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][Sacha's blog]] to show previous buffer in the new window.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (defun my/vsplit-last-buffer (prefix)
       "Split the window vertically and display the previous buffer."
       (interactive "p")
       (split-window-vertically)
       (other-window 1 nil)
       (if (= prefix 1)
         (switch-to-next-buffer)))
     (defun my/hsplit-last-buffer (prefix)
       "Split the window horizontally and display the previous buffer."
       (interactive "p")
       (split-window-horizontally)
       (other-window 1 nil)
       (if (= prefix 1) (switch-to-next-buffer)))

     (bind-key "C-x 2" 'my/vsplit-last-buffer)
     (bind-key "C-x 3" 'my/hsplit-last-buffer)
   #+END_SRC

   Emacs standard way of moving between windows opened in a frame is
   =C-x o=. It jumps the cursor through all windows one by one and can
   not move between frames. I like to have a bit more control and use
   the built in *windmove* package augmented with *framemove*. With
   them, =shift-<arrow>= moves the focus to any window and even does
   wraparound.

   While framemove provides a consistent interface to moving focus, do
   not forget that Emacs behaves exactly like any other application
   with multiple windows: you move between frames (windows belonging
   to the same application) using OS specific keys. On OS X, this is
   =⌘-`=.

   The package description for windmove is good place to start
   reading about it:

   #+BEGIN_SRC emacs-lisp
     ; execute this lisp code in org mode
     ; by placing the curser after the closing parenthesis and press C-x C-e
     (describe-package 'windmove)
   #+END_SRC

   I need to tell org-mode to [[http://orgmode.org/manual/Conflicts.html][allow the windmove]] commands where it
   does not use them for its own purposes. These commands work outside
   headers and lists and has to be called after org-mode (see below).

   #+name: execute-last
   #+BEGIN_SRC emacs-lisp
     (use-package framemove)

     (windmove-default-keybindings)
     (setq windmove-wrap-around t)
     (setq framemove-hook-into-windmove t)

     ;; Make windmove work in org-mode:
     (add-hook 'org-shiftup-final-hook 'windmove-up)
     (add-hook 'org-shiftleft-final-hook 'windmove-left)
     (add-hook 'org-shiftdown-final-hook 'windmove-down)
     (add-hook 'org-shiftright-final-hook 'windmove-right)
   #+END_SRC

*** wn-mode

    Let's try yet an other package [[https://github.com/luismbo/wn-mode][wn-mode]] to change between windows.

    Each window within the active frame gets a number that indicated
    in the mode line among the minor modes. =M-1= and so on move point
    to that window.

   #+name: execute-last
   #+BEGIN_SRC emacs-lisp
     (wn-mode)
   #+END_SRC

** Resize windows

  Buffer windows within frames can be resized but the default keys are
  cumbersome. I have mapped these commands to Apple command key-arrow
  key combinations for ease of use in my Apple laptop.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (setq my/window-resize-step 10)

     (bind-key "s-<left>"
               (lambda () (interactive)
                 (shrink-window-horizontally my/window-resize-step)))
     (bind-key "s-<right>"
               (lambda () (interactive)
                 (enlarge-window-horizontally my/window-resize-step)))
     (bind-key "s-<down>"
               (lambda () (interactive)
                 (shrink-window my/window-resize-step)))
     (bind-key "s-<up>"
               (lambda () (interactive)
                 (enlarge-window my/window-resize-step)))
   #+END_SRC

** External navigation

   This allows you to google the selected region from local emacs buffer. Defines
   function =google=.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (defun google ()
       "Google the selected region if any, display a query prompt otherwise."
       (interactive)
       (browse-url
        (concat
         "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
         (url-hexify-string (if mark-active
                                (buffer-substring (region-beginning) (region-end))
                              (read-string "Google: "))))))
   #+END_SRC
** Global navigation

   This org configuration file has a shortcut =C-c e=.

   This and more files can be reached with my hydra-files by =C-z=.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (defun my/edit-emacs-configuration ()
       (interactive)
       (find-file "~/.emacs.d/emacs.org"))
     (bind-key "C-c e" 'my/edit-emacs-configuration)

     ;; I often want to add more comments to the last note
     (defun my/last-captured-org-note ()
       "Move to the end of penultimate line of the last org capture note."
       (interactive)
       (find-file "~/Dropbox/org/reference.org")
       (end-of-buffer)
       (forward-line -2)
       (org-end-of-line))

     (bind-key "C-c z" 'hydra-goto/body)
     (defhydra hydra-goto (:color blue :hint nil)
       "
       goto   file                        info
              --------------------------------------
              _e_macs.org                 _o_rg
              _r_eference.org: last note
              _w_ork.org
           "
       ("e" (find-file "~/.emacs.d/emacs.org"))
       ("r" my/last-captured-org-note)
       ("w" (find-file "~/Dropbox/org/work.org"))
       ("o" org-info))

   #+END_SRC

   [[http://www.emacswiki.org/emacs/NeoTree_%E4%B8%AD%E6%96%87wiki][NeoTree]] is a file browser plugin that I am trying out. Toggle its
   panel: Emacs, Toggle neoTree =C-x t t=.


   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (use-package neotree
       :init (setq neo-smart-open t) ; always change focus to current buffer
       :config
       ;; fix evil mode key conflicts
       (add-hook
        'neotree-mode-hook
        (lambda ()
          (bind-key "TAB" 'neotree-enter evil-normal-state-local-map)
          (bind-key "SPC" 'neotree-enter evil-normal-state-local-map)
          (bind-key "q"   'neotree-hide  evil-normal-state-local-map)
          (bind-key "RET" 'neotree-enter evil-normal-state-local-map))))
   #+END_SRC

   I like emacs to remember files that I have visited. The =recentf=
   package allows you to see the list using  =C-x C-r=. It comes handy
   when Emacs desktop save looses your file.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (use-package recentf
       :if (not noninteractive)
       :bind ( "C-x C-r" . recentf-open-files)
       :init
       (progn
         (recentf-mode 1)
         (setq recentf-auto-cleanup 'never) ;; cleanup interfers with tramp mode
         (setq recentf-max-saved-items 400
               recentf-max-menu-items 35)))
   #+END_SRC

   I like ~ido~ and ~smex~ for narrowing down files, commands, buffers
   etc. The ido mode is also used to give better interface to
   =recentf=, =C-c r=.

   [[https://github.com/lewang/flx][flx-ido]] gives sparse matching to finding a file or buffer. It puts
   =.*= (match any and any length) between every letter you type. Try
   giving the first letter of all words in the filename to pull that
   file to the top of the list of suggestions.

   [[https://github.com/emacsmirror/ido-vertical-mode][ido-vertical-mode]] replaces deprecated setting I had before. These
   two mods are also mentioned in the [[http://irreal.org/blog/?p=2305][Irreal]] blog.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (use-package ido
       :init
       (setq ido-everywhere t)
       ;; disable ido faces to see flx highlights.
       (setq ido-use-faces nil)
       :config
       ;; make ido display choices vertically
       (ido-vertical-mode 1)
       (ido-mode 1)
       (use-package flx-ido
         ;; display any item that contains the chars you typed
         :init (setq ido-enable-flex-matching t)
         (flx-ido-mode 1)))

     (defun recentf-ido-find-file ()
       "Find a recent file using ido."
       (interactive)
       (let ((file (ido-completing-read
                    "Choose recent file: " recentf-list nil t)))
         (when file
           (find-file file))))
     (bind-key "C-c r" 'recentf-ido-find-file)
   #+END_SRC

   Tell smex that [[http://www.emacswiki.org/emacs/Smex][space inserts '-']] like is customary when typing
   function names in the echo space.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (defadvice smex (around space-inserts-hyphen activate compile)
           (let ((ido-cannot-complete-command
                  `(lambda ()
                     (interactive)
                     (if (string= " " (this-command-keys))
                         (insert ?-)
                       (funcall ,ido-cannot-complete-command)))))
             ad-do-it))
   #+END_SRC

   When I open a file again, I like emacs to show me the place I
   was last time.

   #+name: global-navigation
   #+BEGIN_SRC emacs-lisp
     (use-package saveplace
       :init (setq-default save-place t))
   #+END_SRC

** Geographical location

  Calendar functions like to know your geographical coordinates to
  display celestial movements correctly.

  My Linux box is at KAUST in Saudi Arabia, so the location defaults
  there. On my Mac laptop, the [[https://github.com/purcell/osx-location][osx-location]] package gives the changing
  location automatically.

  #+name: location
  #+BEGIN_SRC emacs-lisp
    (osx-location-watch)

    (defun osx-location-changed-hook ()
      "Set calendar location from OS X. Variables osx-location-latitude
       and osx-location-longitude are set by osx-location."
      (interactive)
      (setq calendar-latitude osx-location-latitude)
      (setq calendar-longitude osx-location-longitude)
      (setq calendar-location-name "Dynamic"))

    (unless (boundp 'calendar-latitude)
      (setq calendar-latitude 60.47)
      (setq calendar-longitude 25.73)
      (setq calendar-location-name "Atorp"))
  #+END_SRC

* Applications

Functionality that otherwise require external applications and are not
really something a normal text editor would do.

** GMail

The gmail setup used is from [[http://blog.binchen.org/posts/notes-on-using-gnus.html][Practical guide to use Gnus with Gmail]].

The main difference is that I am not connecting to Network News
servers at all. This gnus configuration is purely for gmail.

As suggested, I installed w3m and its emacs package:

#+BEGIN_SRC sh
brew install w3m
#+END_SRC

I set up personal information up earlier in this config at the [[Identify yourself]] section.

I have 2-step authentication on my gmail account, so the
=~/.authinfo.gpg= file contains the [[http://support.google.com/accounts/bin/answer.py?answer=185833][gmail application specific password]].

[[https://github.com/redguardtoo/gmail2bbdb][gmail2bbdb]] -converts gmail contacts into bbdb file that gnus calls to
complete email address. Clean the database with =M-x
bbdb-search-duplicates= and use commands =d= for delete and =M-x
bbdb-merge-records=.

#+name: apps
#+BEGIN_SRC emacs-lisp
  (use-package nnir
    :config
    ;; ask encyption password once
    (setq epa-file-cache-passphrase-for-symmetric-encryption t)
    (setq smtpmail-auth-credentials "~/.authinfo.gpg")
    (setq send-mail-function (quote smtpmail-send-it))
    ;;@see http://gnus.org/manual/gnus_397.html
    (setq gnus-select-method
          '(nnimap "gmail"
                   (nnimap-address "imap.gmail.com")
                   (nnimap-server-port 993)
                   (nnimap-stream ssl)
                   (nnir-search-engine imap)
                   (nnimap-authinfo-file "~/.authinfo.gpg")
                   ;; @see http://www.gnu.org/software/emacs/manual/html_node/gnus/Expiring-Mail.html
                   ;; press 'E' to expire email
                   (nnmail-expiry-target "nnimap+gmail:[Gmail]/Trash")
                   (nnmail-expiry-wait 90)))

    (setq-default
     gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f  %B%s%)\n"
     gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
     gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
     gnus-sum-thread-tree-false-root ""
     gnus-sum-thread-tree-indent ""
     gnus-sum-thread-tree-leaf-with-other "-> "
     gnus-sum-thread-tree-root ""
     gnus-sum-thread-tree-single-leaf "|_ "
     gnus-sum-thread-tree-vertical "|")

    (setq gnus-thread-sort-functions
          '((not gnus-thread-sort-by-date)
            (not gnus-thread-sort-by-number)))

    ;; NO 'passive
    (setq gnus-use-cache t)
    (setq gnus-use-adaptive-scoring t)
    (setq gnus-save-score t)
    (add-hook 'mail-citation-hook 'sc-cite-original)
    (add-hook 'message-sent-hook 'gnus-score-followup-article)
    (add-hook 'message-sent-hook 'gnus-score-followup-thread)
    ;; @see http://stackoverflow.com/questions/945419/how-dont-use-gnus-adaptive-scoring-in-some-newsgroups
    (setq gnus-parameters
          '(("nnimap.*"
             (gnus-use-scoring nil))))

    (defvar gnus-default-adaptive-score-alist
      '((gnus-kill-file-mark (from -10))
        (gnus-unread-mark)
        (gnus-read-mark (from 10) (subject 30))
        (gnus-catchup-mark (subject -10))
        (gnus-killed-mark (from -1) (subject -30))
        (gnus-del-mark (from -2) (subject -15))
        (gnus-ticked-mark (from 10))
        (gnus-dormant-mark (from 5))))

    (setq  gnus-score-find-score-files-function
           '(gnus-score-find-hierarchical gnus-score-find-bnews bbdb/gnus-score))

    ;; BBDB: Address list
    (use-package bbdb
      :if (file-exists-p "/usr/share/emacs/site-lisp/bbdb")
      :load-path "/usr/share/emacs/site-lisp/bbdb"
      :init
      (setq bbdb-file "~/emacs.d/bbdb")
      (setq bbdb/mail-auto-create-p t
            bbdb/news-auto-create-p t)
      (defvar bbdb-time-internal-format "%Y-%m-%d"
        "The internal date format.")
      :config
      (bbdb-initialize 'message 'gnus 'sendmail)

      (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus)

             ;;;###autoload
      (defun bbdb-timestamp-hook (record)
        "For use as a `bbdb-change-hook'; maintains a notes-field called `timestamp'
             for the given record which contains the time when it was last modified.  If
             there is such a field there already, it is changed, otherwise it is added."
        (bbdb-record-putprop record 'timestamp (format-time-string
                                                bbdb-time-internal-format
                                                (current-time)))))

    (add-hook 'message-mode-hook
              '(lambda ()
                 (flyspell-mode t)
                 (local-set-key "<TAB>" 'bbdb-complete-name)))

    ;; Fetch only part of the article if we can.  I saw this in someone
    ;; else's .gnus
    (setq gnus-read-active-file 'some)

    ;; Tree view for groups.  I like the organisational feel this has.
    (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)

    ;; Threads!  I hate reading un-threaded email -- especially mailing
    ;; lists.  This helps a ton!
    (setq gnus-summary-thread-gathering-function
          'gnus-gather-threads-by-subject)

    ;; Also, I prefer to see only the top level message.  If a message has
    ;; several replies or is part of a thread, only show the first
    ;; message.  'gnus-thread-ignore-subject' will ignore the subject and
    ;; look at 'In-Reply-To:' and 'References:' headers.
    (setq gnus-thread-hide-subtree t)
    (setq gnus-thread-ignore-subject t)

    ;; Change email address for work folder.  This is one of the most
    ;; interesting features of Gnus.  I plan on adding custom .sigs soon
    ;; for different mailing lists.
    ;; Usage, FROM: My Name <work>
    (setq gnus-posting-styles
          '((".*"
             (name "Heikki Lehväslaiho"
                   (address "heikki.lehvaslaiho@gmail.com"
                            (organization "KAUST")
                            (signature-file "~/.signature")
                            ("X-Troll" "Emacs is better than Vi")
                            )))))

    ;; You need install the command line brower 'w3m' and Emacs plugin 'w3m'
    (setq mm-text-html-renderer 'w3m)
    (use-package w3m
      :ensure t)
    (setq message-send-mail-function 'smtpmail-send-it
          smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
          smtpmail-auth-credentials '(("smtp.gmail.com" 587 "heikki.lehvaslaiho@gmail.com" nil))
          smtpmail-default-smtp-server "smtp.gmail.com"
          smtpmail-smtp-server "smtp.gmail.com"
          smtpmail-smtp-service 587
          smtpmail-local-domain "laptop")
    ;;http://www.gnu.org/software/emacs/manual/html_node/gnus/_005b9_002e2_005d.html
    (setq gnus-use-correct-string-widths nil)


    (defun my-gnus-group-list-subscribed-groups ()
      "List all subscribed groups with or without un-read messages"
      (interactive)
      (gnus-group-list-all-groups 5))

    (add-hook 'gnus-group-mode-hook
              ;; list all the subscribed groups even they contain zero un-read messages
              (lambda () (local-set-key "o" 'my-gnus-group-list-subscribed-groups ))))
#+END_SRC

** News feed reader

   [[https://github.com/skeeto/elfeed][Elfeed]] is a sensible RSS feed reader. =C-c f= starts it and =G=
   updates the article list. =r= marks things as read and =b= opens
   them in browser. There are no folders but you can filter articles
   with =s=. Simple substring search with =BBC= works as expected, but
   to filter using tags, you have to precede them with a plus
   character, e.g. =+emacs=, or =+e= using my abbreviated tags. It
   possible to invert the query using =!= preposition: i.e. to see
   feeds that do *not* match the query string.

   =y= copies the current entry link URL to the clipboard for note taking.

   Tags have to be written out whole before they match anything, so it
   is best to keep them short. Here are the mnemonics that work for
   me:

   | \+tag | name     |
   |-------+----------|
   | b     | Biology  |
   | c     | Comics   |
   | e     | Emacs    |
   | f     | Friends  |
   | j     | Journals |
   | l     | Language |
   | n     | News     |
   | p     | Perl     |
   | s     | Security |


    [[https://github.com/remyhonig/elfeed-org/][elfeed-org]] package that makes elfeed to read the file [[file:elfeed.org][./elfeed.org]]
    for RSS URLs and loads them at runtime. This is more convinient
    than editing the lisp list and evaluating the statement.

    The package author recommended binding filters to unused keys in
    elfeed window. My new keys bind to functions that do all the hard
    work in making selecting tags ever easier:

    | key | function                 | note                                 |
    |-----+--------------------------+--------------------------------------|
    |   0 | elfeed-read-all          | resets to my default filter          |
    |   1 | elfeed-read-news         | world news, removes pesky sport news |
    |   2 | elfeed-read-journals     | science news                         |
    |   3 | elfeed-read-archeology   | archeology news                      |
    |   R | elfeed--mark-all-as-read | one key to mark all visible articles |

    The read functions report their action in the echo field.

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     (use-package elfeed
       :bind ("C-c f" . elfeed)
       ;;:bind-keymap (:map elfeed-search-mode-map
       ;;                    ("1" . elfeed-read-news ))
       :init
       (setq my/default-elfeed-search-filter "@1-month-ago +unread !sport ")
       (setq-default elfeed-search-filter my/default-elfeed-search-filter)
       :config
       (elfeed-org)
       (defun elfeed-mark-all-as-read ()
         "Mark currently shown articles read"
         (interactive)
         (mark-whole-buffer)
         (elfeed-search-untag-all-unread))

       (defun elfeed--read-tag (filter tag)
         "Template for filtering various feed categories.

              FILTER is the filter string to apply, and TAG is a short name of
              the displayed category.

              The cursor is moved to the beginning of the first feed line."
         (setq elfeed-search-filter filter)
         (elfeed-search-update :force)
         (goto-char (point-min))
         (forward-line)
         (message (concat "elfeed: show " tag)))

       (defun elfeed-read-all ()
         "Show all new titles (except sport)"
         (interactive)
         (elfeed--read-tag my/default-elfeed-search-filter "all"))

       (defun elfeed--remove-sports ()
         "Remove sports articles from world news"
         (setq elfeed-search-filter "@1-month-ago +unread +n sport")
         (elfeed-search-update :force)
         (elfeed-mark-all-as-read)
         (message "elfeed: sports removed"))

       (defun elfeed-read-news ()
         "Show global news articles"
         (interactive)
         (elfeed--remove-sports)
         (elfeed--read-tag "@1-month-ago +unread +n " "news"))

       (defun elfeed-read-journals ()
         "Show scientific news from major journals"
         (interactive)
         (elfeed--read-tag "@1-month-ago +unread +j " "journals"))

       (defun elfeed-read-archaeology ()
         "Show archeology news"
         (interactive)
         (elfeed--read-tag "@1-month-ago +unread +a " "archaeology"))

       ;;
       ;; linking and capturing
       ;;

       (defun elfeed-link-title (entry)
         "Copy the entry title and URL as org link to the clipboard."
         (interactive)
         (let* ((link (elfeed-entry-link entry))
                (title (elfeed-entry-title entry))
               (titlelink (concat "[[" link "][" title "]]")))
           (when titlelink
             (kill-new titlelink)
             (x-set-selection 'PRIMARY titlelink)
             (message "Yanked: %s" titlelink))))

       ;; show mode

       (defun elfeed-show-link-title ()
         "Copy the current entry title and URL as org link to the clipboard."
         (interactive)
         (elfeed-link-title elfeed-show-entry))

       (defun elfeed-show-quick-url-note ()
         "Fastest way to capture entry link to org agenda from elfeed show mode"
         (interactive)
         (elfeed-link-title elfeed-show-entry)
         (org-capture nil "n")
         (yank)
         (org-capture-finalize))

       (bind-keys :map elfeed-show-mode-map
                  ("b" . elfeed-show-visit)
                  ("l" . elfeed-show-link-title)
                  ("v" . elfeed-show-quick-url-note)))

       ;; search mode

       (defun elfeed-search-link-title ()
         "Copy the current entry title and URL as org link to the clipboard."
         (interactive)
         (let ((entries (elfeed-search-selected)))
           (cl-loop for entry in entries
                    when (elfeed-entry-link entry)
                    do (elfeed-link-title entry))))

       (defun elfeed-search-quick-url-note ()
         "In search mode, capture the title and link for the selected
     entry or entries in org aganda."
         (interactive)
         (let ((entries (elfeed-search-selected)))
           (cl-loop for entry in entries
                    do (elfeed-untag entry 'unread)
                    when (elfeed-entry-link entry)
                    do (elfeed-link-title entry)
                    do (org-capture nil "n")
                    do (yank)
                    do (org-capture-finalize)
                    (mapc #'elfeed-search-update-entry entries))
           (unless (use-region-p) (forward-line))))

       (bind-keys :map elfeed-search-mode-map
                  ("R" . elfeed-mark-all-as-read)
                  ("0" . elfeed-read-all)
                  ("1" . elfeed-read-news)
                  ("2" . elfeed-read-journals)
                  ("3" . elfeed-read-archaeology)
                  ("l" . elfeed-search-link-title)
                  ("v" . elfeed-search-quick-url-note))
   #+END_SRC

** Twitter

   [[http://www.emacswiki.org/emacs/TwitteringMode][Twittering mode]] ([[https://github.com/hayamiz/twittering-mode][Github]])gives a full blown twitter client with avatar
   images, filtering, and posting. The key map incantation is "Emacs,
   launch twItter", =C-x l i= (because =t= and =w=) were taken).

   I have the prerequisites installed from homebrew: gnutls, GnuPG,
   ImageMagick, gzip.

   Common keys:
   - start =C-x l i=
   - next =j=, previous =k= article
   - open URL in browser =<TAB>...<Enter>=
   - open user timeline =v=
   - interactive timeline =V=
     - e.g. =V #emacs <Enter>= to follow tweets with hashtag #emacs
   - next =f=, previous =b= timeline
   - top of page =H=
   - =u= post new tweet in current timeline

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     (use-package twittering-mode
       :init
       (setq twittering-use-master-password t)
       (setq twittering-icon-mode t)           ; show icons
       (setq twittering-use-icon-storage t)    ; cache icons
       (setq twittering-timer-interval 120)    ; default 90
       :config
       ;; better status format
       (setq twittering-status-format
             "%FOLD{%RT{%FACE[bold]{RT}}%i%s  %r %@{}\n%FILL[          ]{%T%RT{\nretweeted by %s @%C{%Y-%m-%d %H:%M:%S}}}}")
       ;; mode line symbol
       (add-hook 'twittering-mode-hook
                 '(lambda () (setq mode-name "♪"))))
   #+END_SRC

** Web browsing

*** w3m

   The emacs package [[http://www.emacswiki.org/emacs/emacs-w3m][emacs-w3m]] gives access to the commandline
   programme w3m. The [[http://wiki.titan2x.com/index.php?title=W3m_cheat_sheet][w3m cheat sheet]].

   Put the cursor inside an URL and incant: Emacs, lauch web =C-x l w=.

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     (setq browse-url-browser-function 'w3m-browse-url)
     (setq browse-url-browser-function 'browse-url-default-browser)
     (use-package w3m
       :defer t
       :init (setq w3m-use-cookies t)
       :config (autoload 'w3m-browse-url "w3m" "Ask a WWW browser to show a URL." t))
   #+END_SRC

** Buffer sharing

[[http://sachachua.com/blog/2015/02/emacs-peer-peer-coaching-easier-use-impatient-mode-share-buffer/][sacha chua: impatient-mode to share your buffer]]

1. Install the impatient-mode package.
2. Call M-x httpd-start.
3. Configure the firewall to allow incoming connections.
4. Put the selected buffer into impatient-mode.
5. Share the link with my IP address (form: http://my.ip.ad.dress:8080/imp/)

** Blogging with org-page

    [[https://github.com/kelvinh/org-page][org-page]] is simple static page website generator.
    [[https://github.com/kelvinh/org-page/blob/master/doc/quick-guide.org][Quick guide]] gives more details.

    After the setup, I ran command =op/new-repository=. =C-c p=
    displays my hydra key bindings for org-page.

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     (use-package org-page
       :init
       (setq op/repository-directory "~/src/org-page/heikkil.github.io")
       (setq op/site-domain "http://heikkil.github.io")
       (setq op/personal-avatar "https://avatars0.githubusercontent.com/u/75674?v=3&s=460")
       ;; for commenting; disabled now
       ;;(setq op/personal-disqus-shortname "your_disqus_shortname")

       ;; analytics set up at ~/.emacs.secrets file
       ;;(setq op/personal-google-analytics-id "UA-NNNNNNNN-N")

       (setq op/personal-github-link "https://github.com/heikkil")
       ;; slogans
       (setq op/site-main-title "Heikki @ home")
       (setq op/site-sub-title "Loose leaves from my tree")

       ;; set up my own theme since a sans option does not exist
       (setq op/theme-root-directory "~/src/org-page/heikkil.github.io/themes")
       (setq op/theme 'sans)  ; mdo is default, phaer is simpler and uses serif fonts
       :config
       (defhydra hydra-blog (:color blue :hint nil)
         "
          blog  _n_: new post                        _l_: publish last commit
                _r_: reset & publish all             _p_: publish interactively
                _t_: reset & publish to /tmp/blog    _e_: new-repository
                "
         ("n" op/new-post)
         ("r" (progn
                (setq op/item-cache nil)
                (op/do-publication t nil nil t t)))
         ("t" (progn
                (setq op/item-cache nil)
                (op/do-publication t "/tmp/blog" nil t nil)))
         ("l" (op/do-publication nil "HEAD~1" nil t t))
         ("p" op/do-publication)
         ("e" op/new-repository))
       :bind ("C-c o" . hydra-blog/body))
   #+END_SRC

** Ediff

   [[http://oremacs.com/2015/01/17/setting-up-ediff/][Better defaults]] for ediff.

   Remember the spell "Emacs, Launch eDiff", =C-x l d=.

   This setting activates [[http://www.emacswiki.org/emacs/WinnerMode][winner mode]] to return the previous window
   setup by =C-c left=.

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     ;; custom macro for changing custom values
     (defmacro csetq (variable value)
       `(funcall (or (get ',variable 'custom-set)
                     'set-default)
                 ',variable ,value))

     ;; no separate frame for the control panel
     (csetq ediff-window-setup-function 'ediff-setup-windows-plain)
     ;; split horizontally
     (csetq ediff-split-window-function 'split-window-horizontally)
     ;; ignore whitespace
     (csetq ediff-diff-options "-w")

     ;; remove ediff buffers and restore previous window settings
     (use-package winner
       :ensure t
       :config (winner-mode 1)
       (add-hook 'ediff-after-quit-hook-internal 'winner-undo))
   #+END_SRC

** Phonetic alphabet

   [[http://en.wikipedia.org/wiki/NATO_phonetic_alphabet][NATO
   phonetic alphabet] is an invaluable help in passing names and IDs
   through bad telephone or slow network lines. Next time you call the
   airline with your reservation number, write it down, select it and
   apply function =M-x nato-region= or =C-x l n=.

   *Note*: =nato-region= does not place the cursor at the end of the
   converted region if the last character has been converted. This
   prevents you direct application of =denato-region= to reverse the
   change.

** Regex tool

   Coming from perl regexps, I find emacs regexps confusing. Launch
   =re-builder= to match anything in your current buffer. The shortcut
   is "Emacs, launch re-builder", =C-x l r=.

   As recommened in [[http://www.masteringemacs.org/article/re-builder-interactive-regexp-builder][Mastering emacs]], I've set the syntax to "string"
   that escaped one set of backlashes. =C-c C-w= will copy the created
   regexp *and* correct the syntax to be pasted into elisp.

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     (use-package re-builder
       :defer 5
       :init
       (setq reb-re-syntax 'string))
   #+END_SRC

   =M-x qrr= runs =query-replace-regexp= that by default has a really
   complicated key binding =M-C-S %=.

   Read more on [[http://www.emacswiki.org/emacs/RegularExpression][emacs regexps]].

** ChangeLog mode

   While git and other distributed version control systems (see
   [[Version control]]) do a great job in keeping track of changes
   projects, sometimes you need something more general. Enter ancient
   [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Change-Log-Commands.html][ChangeLog]] mode that predates all version control systems. It
   assumes that there is file called =ChangeLog= somewhere in the
   file hierarchy above the current file and gives you a strange key
   chord =C-x 4 a= to add an entry to it.

   I use it to keep a log of OS-wide changes to my computers (thanks
   for Martin Senger for teaching me the habit!). Each computer has a
   ChangeLog file in its own directory and the whole project is under
   git control. When running install, uninstall, or configure commands
   I open the relevant file and create a record of the change and
   where the information came from.

** How Do I?

   Query programming problems within emacs by =howdoi-query= or
   =howdoi-query-line-at-point=. This will google the answer in
   [[http://stackoverflow.com/][StackOverflow]], and parse and return best answers.

   #+BEGIN_SRC emacs-lisp
     ; execute this lisp code in org mode
     ; by placing the curser after
     ; the closing parenthesis and press C-x C-e
     (describe-package 'howdoi)
   #+END_SRC

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     (use-package howdoi
       :defer 5)
   #+END_SRC

** Toys

*** xkcd comics

    The [[https://github.com/vibhavp/emacs-xkcd][xkcd]] package implements an [[Http://xkcd.com/][xkcd]] comics reader for Emacs: =C-c x=.

    | Keybinding | Use                             | Function                        |
    |------------+---------------------------------+---------------------------------|
    | t          | Show alt-text in the minibuffer | (xkcd-alt-text)                 |
    | r          | Show random strip               | (xkcd-rand)                     |
    | q          | Kill buffer                     | (xkcd-kill-buffer)              |
    | <right>    | Load next xkcd                  | (xkcd-next)                     |
    | <left>     | Load previous xkcd              | (xkcd-prev)                     |
    | o/b        | Show strip in browser           | (xkcd-open-browser)             |
    | e          | Show explanation to strip       | (xkcd-open-explanation-browser) |

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     (use-package xkcd
       :bind ("C-c x" . xkcd))
       :config
       (bind-keys :map xkcd-mode-map
                  ("b" . xkcd-open-browser))
   #+END_SRC

*** 2048-game

    Start a pure emacs and text-only version of the [[http://gabrielecirulli.github.io/2048/][2048]] game with
    =C-x l 2=.

   #+name: apps
   #+BEGIN_SRC emacs-lisp
     (use-package 2048-game
       :defer 5)
   #+END_SRC

* Org Mode

  [[http://orgmode.org/][Org mode]] is for all writing of plain text. Use org mode rather than
  plain text mode even when the file extension is =.txt=.

  Let's bind the org mode online info into hydra-goto =C-c z o= since
  it is so useful.

  [[https://github.com/calvinwyoung/org-autolist][org-autolist]] makes org lists behave more like you'd expect: =Return=
  inserts a new list item and =backspace= removes the bulletpoint and
  backs up to previous list item.

  Org mode has a large selected special symbols (like \=alpha=) to
  enter characters into the text. Exporting converts them to the
  proper Unicode character or symbol for that output. I my org mode,
  the entities are rendered as symbols. You can toggle that with =C-c
  C-x \=. The list of all entities can be seen in a buffer with =M-x
  org-entities-help=.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.txt$" . org-mode))

     (add-hook 'org-mode-hook (lambda () (org-autolist-mode)))

     ;; to have \alpha, \to and others display as utf8
     ;; http://orgmode.org/manual/Special-symbols.html
     (setq org-pretty-entities t)
   #+END_SRC

** Agenda

   First you have to tell org-mode which files contain your agenda
   items. The following setup adds all files from a given directory. I
   am using DropBox to get one more way to backup these important
   files.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-files '("~/Dropbox/org"))
   #+END_SRC

   Next I set the agenda calendar work week to start on Sunday
   according to Saudi Arabian custom. Also, I need reminders of
   holidays in Finland.

   I learned ways to speed up agenda generation from [[http://punchagan.muse-amuse.in/posts/how-i-learnt-to-use-emacs-profiler.html][learn profiler]].

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (use-package suomalainen-kalenteri
       :init (setq org-agenda-start-on-weekday 1)) ;; 1 is default
     ;; speed-ups
     (setq org-agenda-inhibit-startup t)
     (setq org-agenda-use-tag-inheritance nil)
   #+END_SRC

   You can add tags to any agenda item  manually or preferably by pulling
   them from a list. At the agenda item header, hit =C-c C-q= to see the
   list and select any subset of tags by pressing the shortcut key(s).

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
    (setq org-tag-alist (quote (("ATORP"  . ?a)
                               ("BIO"     . ?b)
                               ("COMP"    . ?c)
                               ("EMACS"   . ?e)
                               ("FOOD"    . ?d)
                               ("PHOTO"   . ?f)
                               ("GIT"     . ?g)
                               ("HUMEVO"  . ?h)
                               ("LATEX"   . ?l)
                               ("MOVIE"   . ?m)
                               ("ORG"     . ?o)
                               ("PERL"    . ?p)
                               ("SECURITY". ?s)
                               ("WRITING" . ?w)
                               ("PYTHON"  . ?y)
                               ("ZSH"     . ?z))))
   #+END_SRC

   The agenda command pulls all active events and todos from files
   together.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c a" 'org-agenda)
     (bind-key "C-c c" 'org-capture)
     (bind-key "C-c l" 'org-store-link)
     (setq org-return-follows-link t)
   #+END_SRC

   In addition, use =C-c C-l= to paste the link stored with =C-c l=.
   Links on org-mode are now followed by pressing return on a link.

   Org-agenda needs to load before calling =org-agenda=.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (use-package org-agenda)
   #+END_SRC

   I prefer agenda listing for a fortnight and warnings 5 days
   before deadline.

   With line =%%(diary-lunar-phases)= in the calendar.org file, the
   phases are displayed -- now with symbols.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-span 14)
     (setq org-deadline-warning-days 5)

     ;; clean agenda
     (setq org-agenda-skip-deadline-if-done t)
     (setq org-agenda-skip-scheduled-if-done t)

     (setq lunar-phase-names
           '("● New Moon"
             "☽ First Quarter Moon"
             "○ Full Moon"
             "☾ Last Quarter Moon"))
   #+END_SRC

** Capture templates

   First we have to tell emacs where we want to store all captured
   notes.  I keep all files in DropBox.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-directory "~/Dropbox/org")
     (setq org-default-notes-file "~/Dropbox/org/reference.org")
   #+END_SRC

   I copied these capture templates from [[http://doc.norang.ca/org-mode.html][this excellent page]] and
   modified to my own use. I try to minimize refiling.  I have three
   main categories of entries:
   1) *notes [n]* for all note taking (URLs, ideas, papers,...) that
      you want to file away for later retrieval. They are time stamped,
      stored in that order and have optional tags I defined in the
      previous section.
   2) *todos [t]* for notes with scheduled starting time (defaults
      to date only). These will apper in the agenda.
   3) *events [e]* regular events with no completion but date and
      time. If an event is a recurring one, it will edited and moved
      to a different section of the file.

   Each category of entries are stored in their own files. Events are in
   =calendar.org= that starts with sections for anniversaries and
   other recurring tasks.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     ;; Capture templates for: general notes, TODO tasks, events
     (setq org-capture-templates
           (quote(("n" "note" entry (file+datetree "~/Dropbox/org/reference.org")
                   "* %?\nEntered on %U\n  %i")
                  ("t" "todo" entry (file+datetree "~/Dropbox/org/todo.org")
                   "* TODO %?\n     SCHEDULED: %t\n%i\nEntered on %U")
                  ("e" "event" entry (file+datetree "~/Dropbox/org/calendar.org")
                   "* %?\n     %T\n%i\nEntered on %U"))))
   #+END_SRC

   Todos can have additional keywords with dates: =DEADLINE= =C-c C-d=
   for the time the task needs to be finished, and =SCHEDULED= =C-c
   C-s= for the date when to start working on the task.

   Additionally, there are templates for the [[Ledger]] accounting program
   for several accounts. The path to the file must exist.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-capture-templates
           (append '(("l" "Ledger entries")
                     ("lm" "MasterCard" plain
                      (file "~/Documents/ledger/refile.led")
                      "
     %(org-read-date)  %^{Payee}
          ; entered: %U
          Liabilities:MasterCard
          Expenses:%^{Account}              € %^{Amount}
     " :empty-lines-before 1)
                     ("lc" "Cash" plain
                      (file "~/Documents/ledger/refile.led")
                      "
     %(org-read-date) * %^{Payee}
         ; entered: %U
         Expenses:Cash
         Expenses:%^{Account}              %^{Amount}
     " :empty-lines-before 1 )
                     ("ls" "SAR debit" plain
                      (file "~/Documents/ledger/refile.led")
                      "
     %(org-read-date) * %^{Payee}
         ; entered: %U
         Assets:Samba
         Expenses:%^{Account}              %^{Amount} SAR
     " :empty-lines-before 1 )
        ("le" "EUR debit" plain
                      (file "~/Documents/ledger/refile.led")
                      "
     %(org-read-date) * %^{Payee}
         ; entered: %U
         Assets:Heikintili
         Expenses:%^{Account}               € %^{Amount}
     " :empty-lines-before 1 ))
            org-capture-templates))
   #+END_SRC

** Org Dropbox

   [[https://t.co/rhSgJ6zrjD][org-dropbox]] is my own package that is now available in MELPA. It
   creates a minor mode that syncs DropBox notes from mobile devices
   into an org datetree file that is part of my org agenda. The minor
   mode starts a daemon that periodically scans the note directory.

   With org-dropbox-mode on, I can browse news in my phone, add
   interesting articles to Dropbox, and these notes will automatically
   pop into my main capture file =reference.org= that is searchable
   using org agenda commands.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (use-package org-dropbox
       :defer 5
       :config (org-dropbox-mode))
   #+END_SRC

** Refile

   Captured notes should be kept in a temporary file and periodically
   refiled into their proper places. Or so goes the threory. Since I
   create all notes directly directly into the correct file, there is nothing
   to refile. This block is here only as a reminder.

   Refile =(org-refile)= is bound to =C-c C-w=.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     ;; Targets include this file and any file contributing to the agenda - up to 3 levels deep
     (setq org-refile-targets (quote ((nil :maxlevel . 3)
                                      (org-agenda-files :maxlevel . 3))))

     ;; Use full outline paths for refile targets - we file directly with IDO
     (setq org-refile-use-outline-path t)

     ;; Targets complete directly with IDO
     (setq org-outline-path-complete-in-steps nil)

     ;; Allow refile to create parent tasks with confirmation
     (setq org-refile-allow-creating-parent-nodes (quote confirm))

     ;; Use IDO for both buffer and file completion and ido-everywhere to t
     (setq org-completion-use-ido t)
     (setq ido-everywhere t)
     (setq ido-max-directory-size 100000)
     (ido-mode (quote both))

     ;; Refile settings
     ;; Exclude DONE state tasks from refile targets
     ;;(defun bh/verify-refile-target ()
     ;;  "Exclude todo keywords with a done state from refile targets"
     ;;  (not (member (nth 2 (org-heading-components)) org-done-keywords)))
     ;;
     ;;(setq org-refile-target-verify-function 'bh/verify-refile-target)

   #+END_SRC

** Time tracking

   This combines all commands I know about time management under org
   mode to one that can be launched with =C-c w= /endash w for work.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-clock-persist 'history)
     (org-clock-persistence-insinuate)
     (setq org-log-note-clock-out t)

     (bind-key "C-c w" 'hydra-org-time/body)
     (defhydra hydra-org-time (:color blue :hint nil)
       "
    Clock   In/out^     ^Edit^   ^Summary     (_?_)
    -----------------------------------------
            _i_n         _e_dit   _g_oto entry
            _c_ontinue   _q_uit   _d_isplay
            _o_ut        ^ ^      _r_eport
          "
       ("i" org-clock-in)
       ("o" org-clock-out)
       ("c" org-clock-in-last)
       ("e" org-clock-modify-effort-estimate)
       ("q" org-clock-cancel)
       ("g" org-clock-goto)
       ("d" org-clock-display)
       ("r" org-clock-report)
       ("?" (org-info "Clocking commands")))
   #+END_SRC

   See [[http://orgmode.org/manual/Clocking-work-time.html][Clocking work time]].

** TODO MobileOrg
   Use Dropbox for syncing my agenda files with my Android
   phone. Worry about the security implications later.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-mobile-directory "~/Dropbox/org")
   #+END_SRC
** External jars

   Tell org where to find external dependencies. Ditaa and PlantUML
   executable are java jar files. Ditaa is part of org-mode git repository but
   you have to download [[http://sourceforge.net/projects/plantuml/files/plantuml.jar/download][PlantUML]] and place somewhere where Emacs can
   find it. I am using [[http://brew.sh/][homebrew]] to maintain a recent copy of both with
   a shell script wrapper.

   The org code seems to require the direct access to the jar file.
   Run this perl code create a symbolic link after installation or upgrade.

   #+HEADERS: :results output :exports both :shebang "#!/usr/bin/env perl"
   #+BEGIN_SRC perl :tangle yes
     use strict;
     use warnings;

     my $file = '/usr/local/bin/plantuml';
     my $data;
     {
         open my $fh, '<', $file or die;
         $/ = undef;
         $data = <$fh>;
         close $fh;
     }
     my ($jar) = $data =~ /jar +([^ ]+)/;
     `ln -s $jar "${file}.jar"`;
   #+END_SRC

   The [[https://github.com/zwz/plantuml-mode][plantuml-mode]] helps editing the code.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     ;; ditaa
     (setq org-ditaa-jar-path "/usr/local/bin/ditaa.jar")
     ; plantuml-mode
     (setq plantuml-jar-path (expand-file-name "/usr/local/bin/plantuml.jar"))
     (setq org-plantuml-jar-path plantuml-jar-path)
   #+END_SRC

** TODOs

   Make custom markers for todo items:

   - TODO :: something that needs to be done at some point. If it
             has a date, it should be done on that day but it may be
             moved.

   - PENDING :: something that's awaiting feedback from someone
                else. If it has a date, it needs followup if there
                hasn't been any feedback at that time.

   - MEETING :: a scheduled meeting and cannot easily be rescheduled.

   - DONE    :: done.

   - CANCELED :: can be ignored. May include a note on why it's been
                 cancelled.

   Apply todo markers by placing the cursor on the header or item line
   and shift arrow left or right, or accessing the list by =C-c C-t=.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-todo-keywords
           '((sequence "TODO(t)" "PENDING(p)" "MEETING(m)" "|" "DONE(d)" "CANCELED(c)")))

   #+END_SRC

   Automatically mark todo items with todo subitems as DONE when all
   subitems are done.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp

     (defun my-org-autodone (n-done n-not-done)
       "Switch entry to DONE when all subentries are done, to TODO otherwise."
       (let (org-log-done org-log-states)   ; turn off logging
         (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

     (add-hook 'org-after-todo-statistics-hook 'my-org-autodone)

   #+END_SRC

   I want to file and refile notes to any main header in any file in
   my =org-agenda-files= list.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-refile-targets '((nil :level . 3)
                                (org-agenda-files :level . 3)))

   #+END_SRC

   Add timestamp to all DONE items.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-log-done 'time)
   #+END_SRC

** Checkboxes in HTML

   The first snippet (from [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][Sacha.org]]) turns - [X] into ☑ and - [ ] into ☐,
   but leaves [-] alone in HTML export.

   The second uses [[https://github.com/sabof/org-bullets][org-bullets]] to beautify org header bullets with
   pretty UTF-8 characters.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-html-checkbox-type 'unicode)
     (setq org-html-checkbox-types
      '((unicode (on . "<span class=\"task-done\">&#x2611;</span>")
                 (off . "<span class=\"task-todo\">&#x2610;</span>")
                 (trans . "<span class=\"task-in-progress\">[-]</span>"))))

     (use-package org-bullets
       :ensure t
       :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

** Org Babel

   Run code with a block by =C-c C-c= without confirmation. This is a
   known security risk, but makes life easier. Beware.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC

   If you have more than one interpreter for any of the languages in
   code blocks, you better set it explicitly. My main python with all
   modern libraries is Anaconda python version 3.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     ;; Alternative python interpreter for babel blocks
     (setq org-babel-python-command "/Users/lehvasho/miniconda3/bin/python")
   #+END_SRC

   Use syntax highlighting ("fontification") in org-mode source
   blocks, and use a slightly darker background to visually separate
   the source block from its surroundings.

   This also highlights source blocks in HTML exports.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-src-fontify-natively 't)
     (set-face-attribute 'org-block-background nil
                         :background "#f0f0e8")
   #+END_SRC

   Use the =minted= package for syntax highlighting source blocks in
   LaTeX/PDF exports. It needs the python =Pygments= library.
   Install it e.g. =sudo easy_install Pygments=.  Configuration copied
   from a blog post by [[http://joat-programmer.blogspot.nl/2013/07/org-mode-version-8-and-pdf-export-with.html][Florian Bergmann]].  Check also the blog entry by
   [[ http://praveen.kumar.in/2012/03/10/org-mode-latex-and-minted-syntax-highlighting/][Praveen Kumar]].

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     ;; Include the latex-exporter
     (use-package ox-latex)
     ;; Add minted to the defaults packages to include when exporting.
     (add-to-list 'org-latex-packages-alist '("" "minted"))
     ;; Tell the latex export to use the minted package for source
     ;; code coloration.
     (setq org-latex-listings 'minted)
     ;; Let the exporter use the -shell-escape option to let latex
     ;; execute external programs.
     ;; This obviously can be dangerous!
     (setq org-latex-pdf-process
           '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
         ;; alternative
         ;;'("latexmk -shell-escape -interaction=nonstopmode -pdf -f %f"))
   #+END_SRC


   My additions and overrides inlude export to Beamer presentations, too.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
      (use-package ox-beamer)
   #+END_SRC

   Slower but more robust latex-to-PDF processing uses =latexmk=. I
   have I commented it out because the above xelatax call seems to work
   well.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
    ;;(setq org-latex-pdf-process
    ;;'("/usr/texbin/latexmk -interaction=nonstopmode -shell-escape -pdflatex=/usr/texbin/xelatex -gg -f -pdf %f"))
   #+END_SRC


   Untangle files; i.e. write org code blocks to their own files.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c i" 'my/org-babel-untangle)

     (defun my/org-babel-untangle (path)
       (interactive "fFile to include: ")
       (message "Untangling '%s'..." path)
       (save-current-buffer
         (let ((lang (save-current-buffer
                       (set-buffer (find-file-noselect path))
                       (my/mode->language major-mode))))
           (insert (format "\n** %s\n\n#+BEGIN_SRC %s :tangle %s\n"
                           (capitalize (replace-regexp-in-string "\\[_-\\]" " " (file-name-base path)))
                           lang
                           (file-relative-name path)))
           (forward-char (cadr (insert-file-contents path)))
           (insert "\n#+" "END_SRC\n"))))

     (defun my/mode->language (mode)
       "Return the language for the given mode"
       (intern (replace-regexp-in-string "\\-mode$" "" (my/->string mode))))

     (defun my/org-babel-untangle-tree (path)
       (interactive "Droot directory to untangle: ")
       (mapc 'my/org-babel-untangle
             (cl-remove-if 'file-directory-p
                           (f-files path (lambda (p) t) t))))

   #+END_SRC

   Display  and refresh images created by a source block in the same document.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
    (setq org-startup-with-inline-images t)
    (add-hook 'org-babel-after-execute-hook
          (lambda () (org-redisplay-inline-images)))
   #+END_SRC

  Enable flycheck in org-buffer  ([[http://www.wisdomandwonder.com/link/9573/how-to-correctly-enable-flycheck-in-babel-source-blocks][from here]])

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (defadvice org-edit-src-code (around set-buffer-file-name activate compile)
       (let ((file-name (buffer-file-name)))
         ad-do-it
         (setq buffer-file-name file-name)))
   #+END_SRC

** Org export

   I add a formats to org export menu =C-c C-e=: markdown for
   bitbucket.
# and odt for LibreOffice.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (use-package ox-md)
     ;; /Applications/Emacs.app/Contents/Resources/etc/org/
     ;;(setq org-odt-data-dir "~/.emacs.d/etc/")
     ;;(use-package ox-odt)
   #+END_SRC

   Setting the =org-odt-data-dir= is a hack. Why does not emacs find
   the files in any of my locations by itself?

** Latex export

   This defines a new latex class =fu-org-article= based on the
   article class that has fresher and more compact look than the
   default article. The fonts used in the output are [[http://www.linuxlibertine.org/][Linux
   Libertine]]. The Latex binaries and packages come from [[http://www.tug.org/texlive/][Tex Live]].

   I have amended and modified the original code from [[http://emacs-fu.blogspot.com/2011/04/nice-looking-pdfs-with-org-mode-and.html][emacs-fu]] blog
   quite a bit.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-latex-classes
                  '("fu-org-article"
                    "\\documentclass[11pt,a4paper]{article}
          \\usepackage[T1]{fontenc}
          \\usepackage{xunicode}        % for XeTex
          \\usepackage{fontspec}        % for XeTex
          \\usepackage{xltxtra}         % for XeTex
          \\usepackage{url}             % for XeTex to break long URLs at line ending
          \\usepackage[english,finnish]{babel}  % for XeTex
          \\selectlanguage{english}
          \\usepackage[osf]{libertine}  % Libertine fonts with old-style numbers
          \\usepackage{graphicx}
          \\usepackage{minted}
          \\usepackage{hypernat}
          \\usepackage[round]{natbib}

          \\usepackage{paralist}
          \\let\\itemize\\compactitem
          \\let\\description\\compactdesc
          \\let\\enumerate\\compactenum

          \\usepackage[a4paper, textheight=10in,
                      marginparsep=7pt, marginparwidth=.6in]{geometry}

          \\usepackage[colorlinks=true,urlcolor=black,linkcolor=black,citecolor=blue]{hyperref}

          \\let\\nofiles\\relax % Void the \\nofiles command

          \\pagestyle{plain}
          \\title{}
                [NO-DEFAULT-PACKAGES]
                [NO-PACKAGES]"
                    ("\\section{%s}" . "\\section*{%s}")
                    ("\\subsection{%s}" . "\\subsection*{%s}")
                    ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                    ("\\paragraph{%s}" . "\\paragraph*{%s}")
                    ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


     ;; tufte export from https://github.com/smadhueagle/prelude/blob/master/personal/org-latex-custom.el
     ;; tufte-book class for writing classy books
     (add-to-list 'org-latex-classes
                  '("tufte-book"
                    "\\documentclass{tufte-book}
     \\usepackage[T1]{fontenc}
     \\usepackage{color}
     \\usepackage{amssymb}
     \\usepackage{gensymb}
     \\usepackage{nicefrac}
     \\usepackage{microtype}
     \\usepackage{units}"
                    ("\\chapter{%s}" . "\\chapter*{%s}")
                    ("\\section{%s}" . "\\section*{%s}")
                    ("\\subsection{%s}" . "\\subsection*{%s}")
                    ("\\paragraph{%s}" . "\\paragraph*{%s}")
                    ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


     ;; tufte-handout class for writing classy handouts and papers
     (use-package ox-latex)
     (add-to-list 'org-latex-classes
                  '("tufte-handout"
                    "\\documentclass{tufte-handout}
     \\usepackage[T1]{fontenc}
     \\usepackage{color}
     \\usepackage{amssymb}
     \\usepackage{amsmath}
     \\usepackage{gensymb}
     \\usepackage{nicefrac}
     \\usepackage{units}
     \\usepackage[a4paper]{geometry}"

                    ("\\section{%s}" . "\\section*{%s}")
                    ("\\subsection{%s}" . "\\subsection*{%s}")
                    ("\\paragraph{%s}" . "\\paragraph*{%s}")
                    ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))


   #+END_SRC

** Language evaluation support

   #+name: org-config :noweb no-export
   #+BEGIN_SRC emacs-lisp
     (defvar my/org-babel-evaluated-languages
       '(emacs-lisp)
       "List of languages that may be evaluated in Org documents")

     <<org-config-languages>>

     (org-babel-do-load-languages
      'org-babel-load-languages
      (mapcar (lambda (lang)
                (cons lang t))
              my/org-babel-evaluated-languages))
   #+END_SRC

   Org-Babel needs to know which languages to evaluate. I collect all
   languages here, then enable all of them at the end of the section.

*** General programming languages

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'perl)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'clojure)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'ruby)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'sh)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'python)
   #+END_SRC

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'emacs-lisp)
   #+END_SRC

*** Statistics

    [[http://www.r-project.org/][R]] has been the new S for a long time.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'R)
   #+END_SRC

*** Diagramming

   I like [[http://www.graphviz.org/][Graphviz]] for generating graphs. It takes a few lines of code
   to link graphviz's =dot= mode to =org-babel= so I can include dot
   source in org mode and export with nice looking diagrams.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-src-lang-modes (quote ("dot" . graphviz-dot)))
     (add-to-list 'my/org-babel-evaluated-languages 'dot)
   #+END_SRC

   [[http://ditaa.sourceforge.net/][Ditaa]] is another nice package for turning ASCII art into PNG/EPS
   diagrams. Turn that on, too.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'ditaa)
   #+END_SRC

   [[http://plantuml.sourceforge.net/][PlantUML]] uses Graphviz and therefore needs it installed.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'plantuml)
   #+END_SRC

   The lowest thing around is [[http://www.gnuplot.info/][gnuplot]].

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'gnuplot)
   #+END_SRC

*** Databases

    SQL is relational database language.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'sql)
   #+END_SRC

    SQLite is a common variant of SQL.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'sqlite)
   #+END_SRC

*** Typesetting

   Org code itself can be out into code blocks and evaluated.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'org)
   #+END_SRC

    [[http://latex-project.org/][Latex]] is always needed.

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'latex)
   #+END_SRC

   Lilypond is a [[http://www.lilypond.org/][music typesetting language]].

   #+name: org-config-languages
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'my/org-babel-evaluated-languages 'lilypond)
   #+END_SRC

** Shortcuts for some language blocks

   There are some source blocks that I use more than others. To save
   time typing them, I've defined [[http://www.emacswiki.org/emacs/SkeletonMode][skeletons]] with abbreviations for them.

   *sblk* - Generic with interactive type.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block
       "Insert an org block, querying for type."
       "Type: "
       "#+BEGIN_SRC " str "\n"
       _ -
       "\n#+END_SRC\n")
     (define-abbrev org-mode-abbrev-table "sblk" "" 'skel-org-block-source)
   #+END_SRC

   *pblk* - perl block with shebang

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-perl
       "Insert an org perl block with results in the output."
       ""
       "#+HEADERS: :results output :exports both :shebang \"#!/usr/bin/env perl\"\n#+BEGIN_SRC perl :tangle yes\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "pblk" "" 'skel-org-block-perl)
   #+END_SRC

   *rblk* -- R block  optimised for inline graphics

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-r
       "Insert an org R block with results in the output."
       ""
       "#+HEADER: :session *R* :cache yes :results output graphics :exports both :tangle yes\n#+BEGIN_SRC R  :file a.png  :width 500 :height 500\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "rblk" "" 'skel-org-block-r)
   #+END_SRC

   *splant* - PlantUML Source block

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-plantuml
       "Insert a org plantuml block, querying for filename."
       "File (no extension): "
       "#+BEGIN_SRC plantuml :file " str ".png\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "splant" "" 'skel-org-block-plantuml)
   #+END_SRC

   *sdot* - Graphviz DOT block

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-dot
       "Insert a org graphviz dot block, querying for filename."
       "File (no extension): "
       "#+BEGIN_SRC dot :file " str ".png :cmdline -Kdot -Tpng\n"
       "graph G {\n"
       _ - \n
       "}"
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "sdot" "" 'skel-org-block-dot)
   #+END_SRC


  *sditaa* - Ditaa source block

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-ditaa
       "Insert a org ditaa block, querying for filename."
       "File (no extension): "
       "#+BEGIN_SRC ditaa :file " str ".png  :cmdline -r\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "sditaa" "" 'skel-org-block-ditaa)
   #+END_SRC

   *lblk* - Emacs Lisp source block

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-elisp
       "Insert a org emacs-lisp block"
       ""
       "#+BEGIN_SRC emacs-lisp\n"
       _ -
       "\n#+END_SRC\n")

     (define-abbrev org-mode-abbrev-table "lblk" "" 'skel-org-block-elisp)
   #+END_SRC

** References

   I have one master bib file for references. Package [[https://github.com/cute-jumper/gscholar-bibtex][gscholar-bibtex]]
   can retrieve bibtex entries into it from several sources. Launch it
   with =C-x l g=.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq reftex-default-bibliography
           (quote ("/Users/lehvasho/Documents/latex/all.bib")))

     (use-package gscholar-bibtex
       :init
       (setq gscholar-bibtex-database-file "/Users/lehvasho/Documents/latex/all.bib")
       (setq gscholar-bibtex-default-source "Google Scholar")
       :config
       (set-face-attribute 'gscholar-bibtex-title nil
                           :height 1.1
                           :foreground "blue"))
   #+END_SRC

   The RefTex package that manages citations needs configuration. =C-c
   (= search for citation in the bibliograhy file. =C-c )= does
   something else...

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (defun org-mode-reftex-setup ()
       (load-library "reftex")
       (and (buffer-file-name) (file-exists-p (buffer-file-name))
            (progn
              ;enable auto-revert-mode to update reftex when bibtex file changes
              (global-auto-revert-mode t)
            (reftex-parse-all))
       (bind-key "C-c )" 'reftex-citation org-mode-map)
       (bind-key "C-c (" 'org-mode-reftex-search org-mode-map))
       )
     (add-hook 'org-mode-hook 'org-mode-reftex-setup)
   #+END_SRC

   Bibliography is needed only in some documents. I have defined an
   abbreviation *obiblio* that adds these two lines to the
   document. Place them to the end. Read more about [[http://merkel.zoneo.net/Latex/natbib.php][natbib]].

   #+BEGIN_EXAMPLE
     \bibliographystyle{natbib}{}
     \bibliography{bibfilename}
   #+END_EXAMPLE

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (define-skeleton skel-org-block-bibl
       "Insert a org/lisp bibliography block"
       ""
       "\n\\bibliographystyle{plainnat}\n\\bibliography{/Users/lehvasho/Documents/latex/all.bib}\n"
       _ -
       "")

     (define-abbrev org-mode-abbrev-table "obiblio" "" 'skel-org-block-bibl)
   #+END_SRC

** Presentation

   This code exports org mode outlines to presentations in fancy HTML5
   Reveal.js format. Read more at [[https://github.com/yjwen/org-reveal/blob/master/Readme.org][GitHub]].

   To start using it, first clone the org-reveal repository, then
   create a copy of the =Readme.org= file and edit it with emacs.

   #+BEGIN_SRC sh
     cd ~/src/
     git clone https://github.com/yjwen/org-reveal.git
   #+END_SRC

   Then activate the org-reveal mode and tell its location to emacs.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq org-reveal-root "/Users/lehvasho/src/reveal.js")
     (use-package ox-reveal
       :if (file-exists-p org-reveal-root))
   #+END_SRC

** Master file fix

   org-mode asks for a (LaTeX) master file when opening the first org file in
   emacs. This was discussed at the mailing list and the provided [[http://lists.gnu.org/archive/html/emacs-orgmode/2012-02/msg00759.html][fix]]
   is applied here.

   #+name: org-config
   #+BEGIN_SRC emacs-lisp
     (setq TeX-auto-save t)
     (setq TeX-parse-self t)
     (setq-default TeX-master nil)
     ;; I think this is needed because the variable is not buffer local until Auctex is active
     (make-variable-buffer-local 'TeX-master)

     (defun org-mode-reftex-setup ()
       (setq TeX-master t)
       (load-library "reftex")
       (and (buffer-file-name)
            (file-exists-p (buffer-file-name))
            (progn
          (reftex-parse-all)
          (reftex-set-cite-format "[[cite:%l][%l]]")))
       (bind-key "C-c )" 'reftex-citation org-mode-map)
       (bind-key "C-c (" 'org-mode-reftex-search org-mode-map))
     (add-hook 'org-mode-hook 'org-mode-reftex-setup)

   #+END_SRC

* Configuration file layout

  Here I define the emacs.el file that gets generated by the code in
  this org file.

  #+BEGIN_SRC emacs-lisp :tangle yes :noweb no-export :exports code
    ;;;; Do not modify this file by hand.  It was automatically generated
    ;;;; from `emacs.org` in the same directory. See that file for more
    ;;;; information.
    ;;;;
    ;;;; If you cannot find the `emacs.org` file, see the source
    ;;;; repository at https://github.com/heikkil/emacs-literal-config

    <<environment>>
    <<tools>>
    <<look-and-feel>>
    <<key-bindings>>
    <<formatting>>
    <<abbreviations>>
    <<version-control>>
    <<spell-checker>>
    <<text-files>>
    <<programming-setup>>
    <<auto-complete>>
    <<local-navigation>>
    <<global-navigation>>
    <<location>>
    <<org-config>>
    <<startup>>
    <<apps>>
    <<execute-last>>
  #+END_SRC

** Hooks and modes

  This section defines some functionality used elsewhere in this
  configuration.

   #+name: tools
   #+BEGIN_SRC emacs-lisp
     (defun my/->string (str)
       (cond
        ((stringp str) str)
        ((symbolp str) (symbol-name str))))

     (defun my/->mode-hook (name)
       "Turn mode name into hook symbol"
       (intern (replace-regexp-in-string "\\(-mode\\)?\\(-hook\\)?$"
                                         "-mode-hook"
                                         (my/->string name))))

     (defun my/->mode (name)
       "Turn mode name into mode symbol"
       (intern (replace-regexp-in-string "\\(-mode\\)?$"
                                         "-mode"
                                         (my/->string name))))

     (defun my/turn-on (&rest mode-list)
       "Turn on the given (minor) modes."
       (dolist (m mode-list)
         (funcall (my/->mode m) +1)))

     (defvar my/normal-base-modes
       (mapcar 'my/->mode '(text prog))
       "The list of modes that are considered base modes for
       programming and text editing. In an ideal world, this should
       just be text-mode and prog-mode, however, some modes that
       should derive from prog-mode derive from fundamental-mode
       instead. They are added here.")

     (defun my/normal-mode-hooks ()
       "Returns the mode-hooks for `my/normal-base-modes`"
       (mapcar 'my/->mode-hook my/normal-base-modes))

   #+END_SRC

* Environment

** Options set using the customize interface

   By default, Emacs saves the options you set via the `customize-*`
   functions in the user init file, which is "~/.emacs.d/init.el" in
   this setup. I prefer to have these data in a separate file,
   =custom.el= that gets created if it does not exist. In this setup
   customizations are only collected to =custom.el= and you should
   later move and reorganize them to this main document.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (unless (file-exists-p custom-file)
       (write-region "" nil custom-file))
     (load custom-file)
   #+END_SRC

** Performance

   Modern computers have considerable larger amounts of memory than a
   little while ago. I reduce garbage collection overhead by giving it
   more memory. Garbage is purged only when the cache is full.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (setq gc-cons-threshold 20000000)
   #+END_SRC

** OS X

*** PATH

   OS X doesn't set the environment from the shell init files for
   graphical applications, but I set PATH and a bunch of other stuff
   there. The =exec-path-from-shell= package will take care of
   that. Thanks to Ting-Yu Lin for pointing it out.

   Although I have been using the fish shell for while, I was only
   recently bitten by a problem of loosing PATH. The fix comes from
   [[https://github.com/purcell/exec-path-from-shell/issues/9][here]]. Unfortunatelly there are still issues.

   No, fish as the default shell does not work. I am now using bash as
   the default shell and both tramp mode and magit pushing that were
   problem previously just work. I configured the terminal program to
    use fish as my interactive shell.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (when (eq system-type 'darwin)
       (if (equal (file-name-nondirectory (getenv "SHELL")) "fish")
           (progn
             (setq path-separator " ")
             (exec-path-from-shell-initialize)
             (setq path-separator ":"))
         (exec-path-from-shell-initialize)))
   #+END_SRC

*** locate

   The =locate= command is not available in OS X so alias it to mdfind.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
    (when (eq system-type 'darwin)
      (setq locate-command "mdfind"))
   #+END_SRC

*** Printing

   Printing under OS X does not work in default emacs.  [[http://www.emacswiki.org/emacs/MacPrintMode][EmacsWiki]] has
   slightly outdated instructions:

   1. Copy [[ https://raw.github.com/marcora/emacs/master/mac-print-mode.el][mac-print-mode.el]] into =~.emacs.d/elisp= directory
   2. htmlize pakage should be already installed
   3. Install latest version of [[http://hmdt.jp/coral/][Coral]] (1.3)
      - Download and open the image file
      - =cp -r /Volumes/Coral1.3/bin/coral.app /Applications/=
      - =cp /Volumes/Coral1.3/bin/coral /usr/local/bin/=
        and edit it so that it calls /Applications/coral.app/Contents/MacOS/coral
   4. Run the following code:

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (use-package mac-print-mode
       :disabled t
       :if (eq system-type 'darwin)
       :bind ("s-p" . mac-print-buffer)
       :config
       (mac-print-mode 1))
   #+END_SRC

   Command-p now exports the current page as HTML and prints using the
   system dialog.

*** URL copying

    The package [[http://orgmode.org/worg/org-contrib/org-mac-link.html][org-mac-link]] grabs links from open applications and
    pastes them to current org-buffer. Great for org capture notes
    =C-c c n=. Type the note title, move the cursor to the body, and
    press =C-x l l= "Emacs, launch link". I only use chrome, so I
    ignore other apps and use directly the chrome link through command
    =org-mac-chrome-insert-frontmost-url=.

    I've combined those all commands and bound them to =C-c v=.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (use-package org-mac-link
       :ensure t
       :if (eq system-type 'darwin)
       :bind ("C-c v" . my/quick-url-note)
       :config
       (defun my/quick-url-note ()
         "Fastest way to capture a web page link"
         (interactive)
         (org-capture nil "n")
         (org-mac-chrome-insert-frontmost-url)
         (org-capture-finalize)))
   #+END_SRC

** Custom lisp package directory

   There are still lisp packages that you have to copy manually and
   import to emacs. This defines =$HOME/.emacs.d/elisp= directory as
   the place for them.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/elisp")
   #+END_SRC

** Load secrets

   I keep slightly more sensitive information in a separate file so
   that I can easily publish my main configuration.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (load "~/.emacs.secrets" t)
   #+END_SRC

** Emacsclient

   In OS X command line and GUI versions of emacs are not the same
   thing and opening a file in a running GUI program is not automatic.
   In the case of emacs, the way around this is *emacsclient* (see
   =man emacsclient=). The emacs needs to run in server mode for the
   emacsclient to open a new frame to edit the file. Only one instance
   of the server can run, so it is best that only the GUI emacs
   launches it.

   [[https://github.com/stsquad/emacs_chrome][Edit-server]] is the emacs code for the Chrome/Chromium extension for
   editing text areas in a better environment.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (when (window-system)
       (server-start))

     (use-package edit-server
       :ensure t
       :if window-system
       :init
       (add-hook 'after-init-hook 'edit-server-start t)
       :config
       (use-package edit-server-htmlize
         :ensure t
         :config
         ;; gmail fix
         (autoload 'edit-server-maybe-dehtmlize-buffer
           "edit-server-htmlize" "edit-server-htmlize" t)
         (autoload 'edit-server-maybe-htmlize-buffer
           "edit-server-htmlize" "edit-server-htmlize" t))
       (add-hook 'edit-server-start-hook 'edit-server-maybe-dehtmlize-buffer)
       (add-hook 'edit-server-done-hook  'edit-server-maybe-htmlize-buffer))

   #+END_SRC

   A commandline alias *em* (=alias em=emacsclient=) then calls
   emacsclient instead of emacs on the terminal. This will open a new
   emacs frame with the text to edit. To finish editing, save and
   press =C-x #= or =C-x C-3=. This works beautifully with fish shell
   command =funced=.

   #+NAME: environment
   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x C-3" 'server-edit)
   #+END_SRC

   Additionally, for those quick and dirty editing jobs on terminal, I
   have installed *zile*, [[http://www.gnu.org/software/zile/][a lightweight emacs clone]] with homebrew, and
   aliased it to *e*.

   This content goes into =~/.zile= so that zile backups go in the
   same place with emacs:

   #+BEGIN_SRC emacs-lisp
     (setq make-backup-files t)
     (setq backup-directory "~/.emacs.d/backups")
   #+END_SRC
